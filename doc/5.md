ç»ˆäºæ¥åˆ°äº†å®˜æ–¹æ–‡æ¡£å­¦ä¹ çš„æœ€åä¸€ç« ï¼šæ­»çµæœ¯ï¼è¿™ä¸€ç¯‡ä¼šå°½å¯èƒ½ä»ä½å±‚çº§(low level)å»æ­å¼€Rustè¿™é—¨è¯­è¨€çš„é¢çº±ã€‚

æœ¬æ–‡å°†ä¸å†æŒ‰ç…§åŸæœ‰ä¹¦ç±é¡ºåºç»„ç»‡ç¼–å†™ï¼Œè€Œæ˜¯æ ¹æ®æˆ‘è‡ªå·±çš„ä½¿ç”¨ç»éªŒæ’ç‰ˆï¼ŒåŒæ—¶å†…å®¹ä¸é™äºnomiconï¼Œä¼šåŒ…æ‹¬æ‰€æœ‰æˆ‘äº†è§£åˆ°çš„Ruståº•å±‚ç›¸å…³çš„çŸ¥è¯†ã€‚

åŒæ—¶æœ¬æ–‡æ¶‰åŠåˆ°çš„åº•å±‚ä¼šæ¯”è¾ƒå¤šï¼ŒåŒæ—¶æ•´ç†èµ·æ¥éœ€è¦æ—¶é—´ï¼Œæ‰€ä»¥æ›´æ–°ä¼šæŒç»­è¿›è¡Œã€‚

é‚£ä¹ˆæˆ‘ä»¬å¼€å§‹å§ï¼

### å…³äºUnsafe

è£¸æŒ‡é’ˆå¯ä»¥åšçš„äº‹åªæœ‰äº”ç§ï¼š

- è§£å¼•ç”¨è£¸æŒ‡é’ˆï¼›æ¯”å¦‚`UnsafeCell`ä½¿ç”¨åˆ°çš„ä¸å¯å˜å¼•ç”¨ -> å¯å˜å¼•ç”¨
- è°ƒç”¨Unsafeå‡½æ•°(æ¯”å¦‚Cå‡½æ•°ï¼Œç¼–è¯‘å™¨å†…è”å‡½æ•°ï¼Œä»¥åŠåŸç”Ÿå†…å­˜åˆ†é…å™¨)
- å®ç°Unsafeçš„ç‰¹å¾ï¼›æ¯”å¦‚æ‰‹åŠ¨ä¸ºè‡ªå·±çš„ç±»å‹å®ç°`Send`ä»¥åŠ`Sync`
- å¯å˜å…¨å±€å˜é‡ï¼›
- è®¿é—®Cè”åˆä½“çš„å­—æ®µï¼›è¿™ä¸ªæˆ‘ç”¨çš„ä¸å¤šï¼Œå¦‚æœå’ŒCäº¤äº’æ¯”è¾ƒå¤šåˆ™ä¼šç”¨åˆ°

ä¸ºä»€ä¹ˆä¸Šè¿°äº”ç§è¡Œä¸ºå¿…é¡»éœ€è¦Unsafeé™å®šï¼Œæ ¹æœ¬åŸå› åœ¨äºå®ƒä»¬å¯èƒ½å¯¼è‡´UB(Undefined Behavior)ã€‚

å½“ä½ éœ€è¦å’ŒUnsafeäº¤äº’æ—¶ï¼Œåº”è¯¥éµå¾ªç€å°½å¯èƒ½å°‘çš„Unsafeæ‰©æ•£åŸåˆ™ï¼›å³å¦‚æœä»£ç å«æœ‰Unsafeï¼Œåº”å°½å¯èƒ½ä½¿ç”¨ç§æœ‰æ–¹æ³•ï¼Œæ¨¡å—åŒ–ç­‰æ‰‹æ®µé™åˆ¶å¤–éƒ¨å¯¹å…¶çš„è®¿é—®ã€‚å¯¹äºUnsafeçš„ç¼–å†™åº”è¯¥å°½æœ€å¤§å¯èƒ½å»å®¡æŸ¥å’Œè®¤çœŸè€ƒé‡ï¼Œé¿å…åœ¨Safeçš„Rustä¸­äº§ç”Ÿå› ä¸ºUnsafeå¤„ç†ä¸å½“è€Œå¯¼è‡´çš„æ„å¤–å´©æºƒã€‚

ä¸¾ä¸ªç®€å•çš„ä¾‹å­æ¥çœ‹ï¼Œstdä¹‹ä¸‹çš„`Vec`ï¼Œå…¶å†…éƒ¨å®ç°ç”¨äº†Unsafeæ¥ä¼˜åŒ–å’Œç¼–å†™ï¼Œä½†æ˜¯å®ƒæœ€ç»ˆå¯¹å¤–æš´éœ²äº†Safeçš„APIï¼Œé€šè¿‡ä¸¥æ ¼çš„æµ‹è¯•å’Œç¼–å†™ï¼Œæœ€ç»ˆä¿è¯äº†Safeçš„Rustï¼Œè¿™æ ·é€šè¿‡é™åˆ¶Unsafeå¯è§æ€§çš„æ–¹å¼ï¼Œæ­£æ˜¯åˆç†ä½¿ç”¨Unsafeçš„ä¸€ç§è¯æ˜ã€‚

### å…³äºRepr

Reprå¯ä»¥ç†è§£ä¸ºå†…å­˜è¡¨ç°å½¢å¼ï¼Œæˆ–è€…åœ¨å†…å­˜ä¸­çš„å­˜æ”¾æ–¹å¼ã€‚æ¶‰åŠåˆ°çš„æ— éå°±æ˜¯åç§»é‡å’Œå¯¹é½ï¼Œè¿™ä¸€ç‚¹è¯¦ç»†çš„å†…å®¹å¯ä»¥å‚è€ƒ[å‚è€ƒæ‰‹å†Œ](./4.md)ä¸­çš„è¯¦ç»†å™è¿°ã€‚

è¿™é‡Œè¯´ä¸€ä¸‹ZSTç±»å‹ï¼Œå³å¤§å°ä¸ºé›¶çš„ç±»å‹ï¼Œç›®å‰æœ‰è¿™å‡ ç§ï¼š

``` rust
struct Nothing; // No fields = no size

// All fields have no size = no size
struct LotsOfNothing {
    foo: Nothing,
    qux: (),      // empty tuple has no size
    baz: [u8; 0], // empty array has no size
}
```

å…³äºZSTç±»å‹ï¼ŒRustç¼–è¯‘å™¨ä¼šåšå‡ºä¸€äº›ç‰¹æ®Šä¼˜åŒ–ï¼Œè®©é‚£äº›æ¶‰åŠåˆ°ZSTçš„æ“ä½œä¸ºç©ºæ“ä½œã€‚

æœ€åå°±æ˜¯ç©ºç±»å‹ï¼Œä¸€ä¸ªå…¸å‹çš„ç©ºç±»å‹ï¼Œå°±æ˜¯æ²¡æœ‰æšä¸¾å€¼çš„æšä¸¾ç±»å‹ã€‚

æœ‰ä¸€ä¸ªå¾ˆæœ‰è¶£çš„ç”¨æ³•ï¼Œå°±æ˜¯ç”¨åœ¨`Result`ç±»å‹ä¸Šï¼Œå¹¶æŒ‡å®š`Err`ç±»å‹ä¸ºç©ºç±»å‹ï¼Œåˆ™æ­¤æ—¶éšä¾¿`unwarp()`ä¹Ÿä¸ä¼šå‡ºé—®é¢˜ï¼Œä½†æ˜¯å¾ˆå¤šä»Cæ¥çš„ç¨‹åºå‘˜å–œæ¬¢æŠŠç©ºç±»å‹å’Œ`void`ç±»å‹å¯¹æ¯”ï¼Œè¿™æ˜¯ä¸å¯¹çš„ï¼Œå¯ä»¥åˆ›å»ºç©ºç±»å‹çš„å¼•ç”¨ï¼Œä½†æ˜¯æ²¡æ³•å¯¹å…¶è§£å¼•ç”¨ã€‚æ­¤æ—¶`*const`çš„ç”¨æ³•å°±å‡ºç°äº†ï¼å¯¹å®ƒè§£å¼•ç”¨ä¼šè¢«ä¼˜åŒ–æˆç©ºæ“ä½œã€‚

å¯¹äºç©ºç±»å‹çš„`Result`ï¼Œç¼–è¯‘å™¨ä¹Ÿå¯ä»¥åšå‡ºä¼˜åŒ–ï¼Œå³æŠŠ`Result<T, Void>`ä¼˜åŒ–ä¸ºTç±»å‹ã€‚

### æ‰€æœ‰æƒ

å…ˆæ¥çœ‹ä¸€ä¸ªå¼•ç”¨åˆ«åé—®é¢˜ï¼š

``` rust
fn compute(input: &u32, output: &mut u32) {
    if *input > 10 {
        *output = 1;
    }
    if *input > 5 {
        *output *= 2;
    }
    // remember that `output` will be `2` if `input > 10`
}
```

ä¼˜åŒ–ä¹‹åçš„ä»£ç å¦‚ä¸‹ï¼š

``` rust
fn compute(input: &u32, output: &mut u32) {
    let cached_input = *input; // keep `*input` in a register
    if cached_input > 10 {
        // If the input is greater than 10, the previous code would set the output to 1 and then double it,
        // resulting in an output of 2 (because `>10` implies `>5`).
        // Here, we avoid the double assignment and just set it directly to 2.
        *output = 2;
    } else if cached_input > 5 {
        *output *= 2;
    }
}
```

è¿™åœ¨åˆ«çš„è¯­è¨€æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸º`input`å’Œ`output`å¯ä»¥æŒ‡å‘åŒä¸€ä¸ªå†…å­˜ï¼Œä½†æ˜¯åœ¨Rustè¿™æ˜¯ä¸å¯èƒ½çš„ï¼æ‰€ä»¥ç¼–è¯‘å™¨å¯ä»¥ç›´æ¥åšå‡ºä¼˜åŒ–è€Œä¸ç”¨æ‹…å¿ƒå› ä¸ºå‚æ•°åˆ«å(æŒ‡ æŒ‡å‘åŒä¸€ä¸ªå†…å­˜åŒºåŸŸæ—¶)å¯¼è‡´çš„é”™è¯¯ã€‚

å¯¹äºå¼•ç”¨åˆ«åçš„åˆ†æï¼Œå¯ä»¥ä¿ƒä½¿ç¼–è¯‘å™¨åšå‡ºå¾ˆå¤šä¼˜åŒ–ï¼Œæ¯”å¦‚ä¸Šè¿°çš„åˆ«ååˆ†æç»“æœæ˜¯è¾“å…¥è¾“å‡ºäº’ä¸å½±å“ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥è¿›è¡Œä»£ç ä¼˜åŒ–ã€‚ç±»ä¼¼çš„è¡Œä¸ºè¿˜æœ‰ï¼š

- ç¼“å­˜å†…å­˜è®¿é—®è¯»æ“ä½œä¸ºå¯„å­˜å™¨è®¿é—®
- é‡æ’åºè¯»å†™æ“ä½œ

ä¸Šè¿°ä¸€ä¸ªé€šç”¨è¯­è¨€ä¼˜åŒ–çš„ç‰ˆæœ¬åº”è¯¥æ˜¯è¿™æ ·çš„ï¼š

``` rust
fn compute(input: &u32, output: &mut u32) {
    let mut temp = *output;
    if *input > 10 {
        temp = 1;
    }
    if *input > 5 {
        temp *= 2;
    }
    *output = temp;
}
```

å…³äºç”Ÿå‘½å‘¨æœŸçœç•¥ï¼Œç”Ÿå‘½å‘¨æœŸå±€é™æ€§ï¼Œä»¥åŠæ— ç•Œç”Ÿå‘½å‘¨æœŸï¼Œæƒ³å¿…æƒ³ä»£ç çš„æ—¶å€™é‡åˆ°è¿‡å¾ˆå¤šå§ï¼è¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚æ¥çœ‹çœ‹é«˜é˜¶ç”Ÿå‘½å‘¨æœŸçº¦æŸ(Higher-Rank Trait Bound)ï¼Œ

åœ¨è¯¦ç»†å±•å¼€ä¹‹å‰ï¼Œéœ€è¦æ€è€ƒä¸ºä»€ä¹ˆè¦å¼•å…¥è¿™ä¹ˆä¸ªä¸œè¥¿ï¼ŒåŸå› åœ¨äºRuståœ¨åµŒå¥—é’ˆå¯¹Traitçš„ç”Ÿå‘½å‘¨æœŸæ—¶ï¼Œäº§ç”Ÿçš„ç¼ºé™·ï¼Œè€ŒHRTBå°±æ˜¯ä¸ºäº†è§£å†³è¿™ä¸ªç¼ºé™·(æˆ‘ä¸ªäººç†è§£è¿™æ˜¯ä¸€ç§è®¾è®¡ä¸å®Œå–„ï¼Œä¹Ÿè®¸è¯­è¨€ç‰¹æ€§å¦‚æ­¤ï¼Ÿè°çŸ¥é“å‘¢)ã€‚

çœ‹ä¸€ä¸ªä¾‹å­ï¼š

``` rust
fn get_printer(id: i32) -> impl Fn(& str) {
    move |text| {
        println!("Printer {} says: {}", id, text);
    }
}

fn main() {
    let printer1 = get_printer(1);
    let str1: &'static str = "aaa";
    printer1(str1);
    {
        let binding = String::from("bbb");
        let str2: &str = &binding;
        printer1(str2);
    }
}
```

ä¸Šè¿°ä»£ç å¾ˆç®€å•ï¼Œ`get_printer`è¿”å›ä¸€ä¸ªé—­åŒ…ï¼Œè¿™ä¸ªé—­åŒ…å‚æ•°ä¸ºä¸€ä¸ªå¼•ç”¨ï¼Œç„¶åæ‰“å°è¿™ä¸ªå¼•ç”¨ã€‚

å³ç„¶æ˜¯å¼•ç”¨ï¼Œä¸ºä»€ä¹ˆä¸èƒ½ç»™å®ƒåŠ ä¸ªç”Ÿå‘½å‘¨æœŸå‘¢ï¼Ÿè¯•ç€æ‰‹åŠ¨æ·»åŠ ç”Ÿå‘½å‘¨æœŸè¯•è¯•çœ‹ï¼Œå³ï¼Œdesugarï¼š

``` rust
fn get_printer<'a>(id: i32) -> impl Fn(&'a str) {
    move |text| {
        println!("Printer {} says: {}", id, text);
    }
}

fn main() {
    let printer1 = get_printer(1);
    let str1: &'static str = "aaa";
    printer1(str1);
    {
        let binding = String::from("bbb");
        let str2: &str = &binding;
        printer1(str2);
    }
}
```

å¥½ï¼ŒæŠ¥é”™

æ”¹ä¸€ä¸‹ï¼š

``` rust
fn get_printer(id: i32) -> impl for<'a> Fn(&'a str) {
    move |text| {
        println!("Printer {} says: {}", id, text);
    }
}

fn main() {
    let printer1 = get_printer(1);
    let str1: &'static str = "aaa";
    printer1(str1);
    {
        let binding = String::from("bbb");
        let str2: &str = &binding;
        printer1(str2);
    }
}
```

Passedï¼ä¸ºä»€ä¹ˆï¼Ÿ

é¦–å…ˆéœ€è¦ç†è§£ä¸ºä»€ä¹ˆæŠ¥é”™ï¼Œåœ¨ç‰ˆæœ¬2ä¸­ï¼Œæˆ‘ä»¬ç¬¬ä¸€æ¬¡è°ƒç”¨`printer1`ï¼Œç»™çš„æ˜¯`'static`çš„å‚æ•°ï¼Œæ­¤æ—¶ç¼–è¯‘å™¨è®¤ä¸º`printer1`ä¹‹ä¸Šçš„ç”Ÿå‘½å‘¨æœŸä¸º`'static`æ‰å¯¹ï¼Œæ‰€ä»¥ä¹Ÿè¦æ±‚åç»­æ‰€æœ‰çš„è°ƒç”¨éƒ½è¦æ»¡è¶³`'static`ï¼Œä½†æ˜¯å¾ˆæ˜æ˜¾ç¬¬äºŒæ¬¡è°ƒç”¨ï¼Œ`str2`çš„ç”Ÿå‘½å‘¨æœŸä¸æ»¡è¶³ï¼Œæ‰€ä»¥æŠ¥é”™(not live long enough)ã€‚

è€Œæˆ‘ä»¬åŠ ä¸Š`for<'a>`(è¯»ä½œï¼šå¯¹äºä»»æ„çš„'aï¼Œæœ‰... ...)ä¹‹åï¼Œåˆ™æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œæˆ‘ä»¬è¿”å›çš„è¿™ä¸ªFnå¯¹äºä»»æ„çš„ç”Ÿå‘½å‘¨æœŸ(æ— è®ºæ˜¯`'static`è¿˜æ˜¯`'a`ï¼Œ`'b`ä»€ä¹ˆçš„)éƒ½å¯ä»¥æ»¡è¶³å¹¶å¯æ‰§è¡Œï¼Œæ­¤æ—¶ç¼–è¯‘å™¨å°±æ‡‚äº†ï¼Œå¹¶ä¸”ä¸ä¼šäº§ç”Ÿä¸Šè¿°é™åˆ¶ã€‚

è¿™å°±åƒç¼–è¯‘å™¨çš„ä¸€ç§ç¬¨ç¬¨ç†è§£ï¼Œæˆ–è€…æœ¬æ¥å°±æ˜¯è¿™æ ·è®¾è®¡çš„(è¯»å–ç¬¬ä¸€æ¬¡ç”Ÿå‘½å‘¨æœŸå¹¶å•ä¾‹åŒ–)ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦`for<'a>`æ‰‹æ®µæ¥å‘Šè¯‰ç¼–è¯‘å™¨åº”è¯¥æ€ä¹ˆå¯¹å¾…ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸã€‚

[å¦‚ä½•ç†è§£rustä¸­çš„HRTBï¼ˆHigher-Ranked Trait Boundï¼‰ï¼Ÿ - FancyFlameçš„å›ç­” - çŸ¥ä¹ ](https://www.zhihu.com/question/504670139/answer/3136039945)

æœ€åæ¥ä¸€ä¸ªå®Œå…¨ç†è§£çš„ä¾‹å­ï¼š

``` rust
impl<'four> For for &'four dyn for<'fore> For
    where
            for<'fore> dyn For: For,
{
    fn four(self: &&'four dyn for<'fore> For) {
        print!("four")
    }
}

fn main() {
    four(&(four as for<'four> fn(&'four dyn for<'fore> For)))
}

trait For {
    fn four(&self) {}
}

fn four(four: &dyn for<'four> For) {
    <&dyn for<'four> For as For>::four(&{
        ((&four).four(), four.four());
        four
    })
}

impl For for for<'four> fn(&'four dyn for<'fore> For) {
    fn four(&self) {
        print!("for")
    }
}

```

ä¸ºäº†æ”¹å–„ ä¸å®Œå–„ç”Ÿå‘½å‘¨æœŸå®ç° çš„ä½¿ç”¨æ‰€å¯¼è‡´çš„ä¸€äº›é™åˆ¶ä»¥åŠUBè¡Œä¸ºï¼ŒRustå¼•å…¥äº†å­ç±»å‹å’Œåå˜ã€‚

å…ˆæ¥çœ‹çœ‹å­ç±»å‹ï¼Œé¦–å…ˆï¼š

- å­ç±»å‹å¯ä»¥æ›¿ä»£çˆ¶ç±»å‹ï¼Œæ‰€æœ‰å¯¹çˆ¶ç±»å‹çš„çº¦æŸï¼Œå­ç±»å‹ä¸€å®šæ»¡è¶³
- å­ç±»å‹å¯ä»¥å‘ä¸‹å…¼å®¹å¹¶è½¬æ¢ä¸ºçˆ¶ç±»å‹

æ¥çœ‹ä¸€ä¸ªä»£ç ï¼š

``` rust
fn debug<'a>(a: &'a str, b: &'a str) {
    println!("a = {a:?} b = {b:?}");
}

fn main() {
    let hello: &'static str = "hello";
    {
        let world = String::from("world");
        let world = &world; // 'world has a shorter lifetime than 'static
        debug(hello, world); // hello silently downgrades from `&'static str` into `&'world str`
    }
}
```

è¿™åœ¨ä¸å®Œå–„çš„ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿé‡Œï¼Œæ˜¯ç¼–è¯‘ä¸é€šè¿‡çš„ï¼Œç°åœ¨å¯ä»¥ã€‚

å­ç±»å‹æœ‰ä¸€ä¸ªå¾ˆå…¸å‹çš„ç”¨å¤„å°±æ˜¯ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿï¼Œå¦‚æœç”Ÿå‘½å‘¨æœŸ'açš„èŒƒå›´è¦†ç›–äº†ç”Ÿå‘½å‘¨æœŸ'bçš„èŒƒå›´ï¼Œåˆ™å¯ä»¥è®¤ä¸º'aæ˜¯'bçš„å­ç±»å‹ï¼Œå› ä¸º'bèƒ½å¹²çš„æ´»ï¼Œ'aéƒ½å¯ä»¥ã€‚

æ‰€ä»¥ä¸Šè¿°ä»£ç ï¼Œ'staticæ˜¯'açš„å­ç±»å‹ï¼Œå¯ä»¥å…¼å®¹è½¬åŒ–ä¸º'aï¼Œæ‰€ä»¥ç¼–è¯‘é€šè¿‡ã€‚

æ¥çœ‹çœ‹åå˜æ€§ã€‚

åå˜æ€§è®¨è®ºçš„æ˜¯å­ç±»å‹é€šè¿‡æ³›å‹å‚æ•°å®šä¹‰çš„å…³ç³»ï¼Œé€šä¿—ä¸€ç‚¹å°±æ˜¯å½“ä¸€ä¸ªç±»å‹åŒ…å«æ³›å‹æ—¶ï¼Œä¸åŒçš„æ³›å‹ä¹‹é—´çš„å­ç±»å‹å…³ç³»å¦‚ä½•å½±å“è¯¥ç±»å‹çš„å­ç±»å‹å…³ç³»ã€‚å¼€å§‹è®¨è®ºä¹‹å‰ï¼Œå®šä¹‰ä¸€ä¸ªç±»å‹ä¸º`F<T>`ï¼Œå®ƒåŒ…å«ä¸€ä¸ªæ³›å‹å‚æ•°`T`ã€‚

ç±»å‹Fçš„åå˜æ€§æŒ‡çš„æ˜¯æ³›å‹å¦‚ä½•å½±å“F(çš„å­ç±»å‹å…³ç³»)ï¼Œå¦‚æœè¿˜æ˜¯è§‰å¾—ç»•å£ï¼Œå¯ä»¥éšä¾¿æ¢ä¸ªè¯ï¼Œæ¯”å¦‚ï¼šABCè®¨è®ºçš„æ˜¯XXXçš„è¾ˆåˆ†å¦‚ä½•å½±å“åˆ°YYYçš„è¾ˆåˆ†ï¼Œå…¶ä¸­YYYç”¨åˆ°äº†XXXã€‚

ç°åœ¨å±•å¼€ä¸‰ç§åå˜æ€§ï¼š

- åå˜ï¼šFä¹‹é—´çš„å­ç±»å‹å…³ç³»å’Œæ³›å‹å‚æ•°ä¹‹é—´çš„å­ç±»å‹å…³ç³»ä¸€è‡´
- é€†å˜ï¼šä¸ä¸Šè¿°ç›¸å
- ä¸å˜ï¼šFä¹‹é—´ä¸å­˜åœ¨å­ç±»å‹å…³ç³»ï¼Œå³ä½¿æ³›å‹å‚æ•°ä¹‹é—´å­˜åœ¨

åœ¨ä¸Šé¢é‚£ä¸ªå¼•ç”¨çš„ä¾‹å­é‡Œï¼Œ&'a Tæ˜¯&'b Tçš„å­ç±»å‹ï¼Œå¹¶ä¸”'a æ˜¯ 'bçš„å­ç±»å‹(æŠŠç”Ÿå‘½å‘¨æœŸä¹Ÿçœ‹æˆæ³›å‹å‚æ•°)ï¼Œåˆ™æˆ‘ä»¬å¯ä»¥è¯´&'a Tä¹‹äº'aæ˜¯åå˜çš„ã€‚

å†æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

``` rust
fn assign<T>(input: &mut T, val: T) {
    *input = val;
}

fn main() {
    let mut hello: &'static str = "hello";
    {
        let world = String::from("world");
        assign(&mut hello, &world);
    }
    println!("{hello}"); // use after free ğŸ˜¿
}
```

ä¸Šè¿°ç¼–è¯‘ä¸é€šè¿‡ï¼Œå³ä½¿'staticæ˜¯'açš„å­ç±»å‹ï¼Œä½†æ˜¯&'static mut Tåè€Œæ˜¯&mut 'a Tçš„çˆ¶ç±»å‹(è¿™æ˜¯æˆ‘é€ çš„è¯ï¼Œæ„æ€æ˜¯åè¿‡æ¥çš„å­ç±»å‹)ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´&'a mut Tä¹‹äºTæ˜¯é€†å˜çš„ã€‚

æ¥çœ‹ä¸€ä¸ªå…³ç³»å¯¹åº”è¡¨ï¼š

|                 |    'a     |         T         |     U     |
| :-------------- | :-------: | :---------------: | :-------: |
| `&'a T `        | covariant |     covariant     |           |
| `&'a mut T`     | covariant |     invariant     |           |
| `Box<T>`        |           |     covariant     |           |
| `Vec<T>`        |           |     covariant     |           |
| `UnsafeCell<T>` |           |     invariant     |           |
| `Cell<T>`       |           |     invariant     |           |
| `fn(T) -> U`    |           | **contra**variant | covariant |
| `*const T`      |           |     covariant     |           |
| `*mut T`        |           |     invariant     |           |

ä»¥æ­¤ç±»æ¨ï¼Œå¯ä»¥å¾—åˆ°ä¸€äº›å…¶ä»–å¸¸è§ç±»å‹çš„å…³ç³»ï¼š

- Vec<T>ä»¥åŠå…¶ä»–åˆ«çš„æ‰€æœ‰æƒæ™ºèƒ½æŒ‡é’ˆéƒ½å’ŒBox<T>éµå®ˆä¸€æ ·çš„é€»è¾‘
- Cell<T>ä»¥åŠå…¶ä»–å†…éƒ¨å¯å˜æ€§æ™ºèƒ½æŒ‡é’ˆå’ŒUnsafeCell<T>ä¸€æ ·
- UnsafeCell<T>æ‹¥æœ‰çš„å†…éƒ¨å¯å˜æ€§èµ‹äºˆäº†å®ƒå’Œ&mut Tä¸€æ ·çš„é€»è¾‘
- *const Tå’Œ&Tä¸€æ ·
- *mut Tå’Œ&mut Tä¸€æ ·

æ¶‰åŠåˆ°åå˜æ€§çš„åœ°æ–¹æ˜¯å‡½æ•°çš„ä¼ å‚ï¼Œè€Œä¸”ä¸€èˆ¬æ¶‰åŠåˆ°å‡½æ•°æŒ‡é’ˆå’Œç‰¹æ®Šçš„ç”Ÿå‘½å‘¨æœŸï¼Œæ‰€ä»¥é‡åˆ°çš„å¾ˆå°‘ã€‚è¿™åœ°æ–¹å°±ç®—ä¸æ‡‚ä¹Ÿæ²¡ä»€ä¹ˆå¤§äº‹ï¼Œä¸€èˆ¬å¼€å‘ä¸ä¼šæ¶‰åŠåˆ°è¿™ä¹ˆæ·±å…¥çš„å†™æ³•ã€‚

æ¥çœ‹çœ‹ææ„æ£€æŸ¥(DropCheck)ã€‚

åœ¨æ™®é€šçš„letå®šä¹‰æ—¶ï¼Œæˆ‘ä»¬æœ‰ç›¸åçš„ææ„é¡ºåºï¼Œå› ä¸ºå¯ä»¥å±•å¼€ä¸ºï¼š

``` rust
// let x;
// let y;
{
    let x;
    {
        let y;
    }
}
```

è€Œç»“æ„ä½“ï¼Œå…ƒç»„åˆ™æ˜¯æŒ‰ç…§å®šä¹‰é¡ºåºææ„ï¼Œä¸ºä»€ä¹ˆè¦è¯´è¿™ä¸ªå‘¢ï¼Ÿæ¥çœ‹ä¸€ä¸ªæœ‰è¶£çš„ä¾‹å­ï¼š

``` rust
struct Inspector<'a>(&'a u8);

struct World<'a> {
    inspector: Option<Inspector<'a>>,
    days: Box<u8>,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&world.days));
}
```

çœ‹èµ·æ¥æ²¡ä»€ä¹ˆé—®é¢˜ï¼Œå› ä¸ºinspectorå’Œdaysçš„å­˜æ´»æ˜¯ç»‘å®šçš„(ç»‘å®šåœ¨äº†Worldç±»å‹ä¸Š)ï¼Œåªè¦inspectoræ˜¯å­˜æ´»çš„ï¼Œdayså°±æ˜¯å­˜æ´»çš„ã€‚æ‰€ä»¥daysæ˜¯å¦ä¸¥æ ¼é•¿å‘½äºinspector(å³ä¸€å®šæ¯”å®ƒæ´»å¾—ä¹…ï¼Œè€Œä¸æ˜¯ç®€å•çš„å¤§äºç­‰äº)å°±æ— æ‰€è°“äº†ã€‚

å¦‚æœå­˜åœ¨'b: 'aè¿™æ ·çš„å®šä¹‰ï¼Œåˆ™è¡¨ç¤º'bçš„ç”Ÿå‘½å‘¨æœŸèŒƒå›´ä¸€å®šå¤§äºç­‰äº'açš„ï¼Œä½†æ˜¯å¦‚æœåŠ ä¸Šäº†ä¸¥æ ¼å®šä¹‰ï¼Œåˆ™è¡¨ç¤º'bçš„èŒƒå›´å¿…é¡»å¤§äº'açš„ã€‚

ä½†æ˜¯å¦‚æœåŠ ä¸Šææ„å‡½æ•°ï¼Œä¸€åˆ‡å°±å˜äº†ï¼š

``` rust
struct Inspector<'a>(&'a u8);

impl<'a> Drop for Inspector<'a> {
    fn drop(&mut self) {
        println!("I was only {} days from retirement!", self.0);
    }
}

struct World<'a> {
    inspector: Option<Inspector<'a>>,
    days: Box<u8>,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&world.days));
    // Let's say `days` happens to get dropped first.
    // Then when Inspector is dropped, it will try to read free'd memory!
}
```

æ­¤æ—¶åœ¨dropä¸­ï¼Œå› ä¸ºæ‰§è¡Œäº†ä»£ç ï¼Œæ‰€ä»¥å¯èƒ½ä¼šä½¿ç”¨åˆ°å·²ç»è¢«ææ„çš„å€¼(è‡³äºä¸ºä»€ä¹ˆï¼Œä¸æ˜¯dropå…ˆäºå†…å­˜é‡Šæ”¾å—ï¼Ÿå¯èƒ½æ˜¯Rustæœ‰é—®é¢˜æˆ–è€…è€ƒè™‘åˆ°äº†æ›´å¤šçš„å› ç´ ï¼ŒåŸæ–‡ä¹Ÿåªæ˜¯ç»™å‡ºâ€œå¯èƒ½è§‚å¯Ÿåˆ°ç†åº”å­˜æ´»çš„ç±»å‹ç»“æœè¢«å…ˆé‡Šæ”¾äº†â€)ã€‚ä¸ºäº†é¿å…è¿™æ ·çš„é—®é¢˜ï¼Œæˆ‘ä»¬è¦éµå®ˆä¸€æ¡è§„åˆ™ï¼š

æ³›å‹ç±»å‹æƒ³è¦å®ç°å¥å£®çš„ææ„ï¼Œåˆ™å…¶æ³›å‹ä¼ å‚å¿…é¡»ä¸¥æ ¼å­˜æ´»äºç±»å‹ä¹‹å¤–ã€‚

è§£é‡Šä¸€ä¸‹ï¼š

ææ„å‡½æ•°äº§ç”Ÿçš„æ‚¬ç©ºå¼•ç”¨ä»…é™äº**æ³›å‹ç±»å‹**ï¼Œæ‰€ä»¥å¦‚æœä½ åˆšå¥½å®šä¹‰äº†ä¸€ä¸ªæ³›å‹ç±»å‹ï¼Œè¿˜ä½¿ç”¨äº†ææ„å‡½æ•°ï¼Œåˆ™ä¸Šè¿°åŸåˆ™å¿…é¡»æˆä¸ºä½ è¦è€ƒè™‘çš„å› ç´ ï¼Œå› ä¸ºå€Ÿç”¨æ£€æŸ¥å™¨æš‚æ—¶æ²¡æœ‰è¿™ä¹ˆæ™ºèƒ½å»æ¨ç®—è¿™äº›å…³ç³»ã€‚

å¦‚æœåˆç†çš„è®¾è®¡ï¼Œç¡®ä¿ä¸ä¼šç”¨åˆ°å¼•ç”¨ç±»å‹ï¼Œå€Ÿç”¨æ£€æŸ¥å™¨ä¼šé€šè¿‡ç¼–è¯‘å—ï¼Ÿ

çœ‹ä¸€ä¸ªä¾‹å­ï¼š

``` rust
struct Inspector<'a>(&'a u8, &'static str);

impl<'a> Drop for Inspector<'a> {
    fn drop(&mut self) {
        println!("Inspector(_, {}) knows when *not* to inspect.", self.1);
    }
}

struct World<'a> {
    inspector: Option<Inspector<'a>>,
    days: Box<u8>,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&world.days, "gadget"));
    // Let's say `days` happens to get dropped first.
    // Even when Inspector is dropped, its destructor will not access the
    // borrowed `days`.
}
```

è¿™é‡Œæˆ‘ä»¬æ‰“å°äº†ä¸€ä¸ªé™æ€å­—ç¬¦ä¸²ï¼Œä¸‹ä¸€ä¸ªï¼š

``` rust
struct Inspector<T>(T, &'static str);

impl<T> Drop for Inspector<T> {
    fn drop(&mut self) {
        println!("Inspector(_, {}) knows when *not* to inspect.", self.1);
    }
}

struct World<T> {
    inspector: Option<Inspector<T>>,
    days: Box<u8>,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&world.days, "gadget"));
    // Let's say `days` happens to get dropped first.
    // Even when Inspector is dropped, its destructor will not access the
    // borrowed `days`.
}
```

è¿™é‡Œæˆ‘ä»¬åœ¨å®šä¹‰é‡Œå»æ‰å¼•ç”¨ç±»å‹(è™½ç„¶æœ€åä¼ é€’çš„è¿˜æ˜¯å¼•ç”¨)ï¼Œä½†è¿™ä¸¤ä¸ªä¾æ—§é€šä¸è¿‡ï¼ç©¶å…¶åŸå› ï¼Œè¿˜æ˜¯å› ä¸ºç¼–è¯‘å™¨å¤ªå‚»äº†ï¼Œæ²¡æ³•åˆ†æå‡ºè¿™äº›ç»“æœã€‚

æ‰€ä»¥æœ‰æ²¡æœ‰ä¸é‚£ä¹ˆé™åˆ¶çš„å€Ÿç”¨æ£€æŸ¥è®©æˆ‘ä»¬ä½¿ç”¨å‘¢ï¼Ÿæœªæ¥ç‰ˆæœ¬å¯èƒ½ä¼šæ”¹è¿›ï¼Œä½†ç›®å‰æ¥çœ‹ï¼Œå¯ä»¥ä½¿ç”¨unstableçš„dropck_eyepatchç‰¹å¾ä¹‹ä¸‹çš„may_dangleæ ‡æ³¨ï¼Œå®ƒæŒ‡å‡ºåœ¨æ³›å‹ç±»å‹çš„ææ„æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä¸ä¼šè®¿é—®è¿‡æœŸæ•°æ®ã€‚

æ¥çœ‹ä¸€ä¸ªç”¨æ³•ï¼š

``` rust
#![feature(dropck_eyepatch)]

struct Inspector<'a>(&'a u8, &'static str);

unsafe impl<#[may_dangle] 'a> Drop for Inspector<'a> {
    fn drop(&mut self) {
        println!("Inspector(_, {}) knows when *not* to inspect.", self.1);
    }
}

struct World<'a> {
    days: Box<u8>,
    inspector: Option<Inspector<'a>>,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&world.days, "gadget"));
}
```

ä¹‹æ‰€ä»¥æ˜¯unsafeçš„ï¼Œæ˜¯å› ä¸ºå€Ÿç”¨æ£€æŸ¥å™¨ä¸ä¼šå†æ£€æŸ¥åœ¨ææ„æ–¹æ³•ä¸­ï¼Œæ˜¯å¦ä¼šè®¿é—®è¿‡æœŸæ•°æ®ã€‚

ç°åœ¨æˆ‘ä»¬æ¥çœ‹çœ‹PhantomDataã€‚

åœ¨&'a [T]çš„è¿­ä»£ä¸­ï¼Œè¿­ä»£é¡¹çš„å®ç°ä½¿ç”¨æ— ç•Œç”Ÿå‘½å‘¨æœŸï¼Œç»“æ„å¦‚ä¸‹ï¼š

``` rust
struct Iter<'a, T: 'a> {
    ptr: *const T,
    end: *const T,
}
```

ä½†æ˜¯æ— ç•Œç”Ÿå‘½å‘¨æœŸæ˜¯ç¦æ­¢å‡ºç°åœ¨å­—æ®µä¸­çš„ï¼Œæ‰€ä»¥æ­¤æ—¶éœ€è¦ä¸€ä¸ªç©ºå­—æ®µæ¥å ä½ä¸€ä¸‹ï¼š

``` rust
use std::marker;

struct Iter<'a, T: 'a> {
    ptr: *const T,
    end: *const T,
    _marker: marker::PhantomData<&'a T>,
}
```

åŒæ—¶è¿˜å…·æœ‰äº†ä¹‹äº'aå’ŒTçš„åå˜ã€‚

æ—©æœŸçš„Vecä¼šé€šè¿‡æ·»åŠ 

``` rust
use std::marker;

struct Vec<T> {
    data: *const T, // *const for variance!
    len: usize,
    cap: usize,
    _owns_T: marker::PhantomData<T>,
}
```

æ¥è¡¨ç¤ºè‡ªå·±å¯¹äºTçš„æ‰€æœ‰æƒï¼Œä»¥æ­¤æ¥è§¦å‘ææ„æ£€æŸ¥ï¼Œå› ä¸ºVecçš„ææ„ç¡®ç¡®å®å®ä¼šç”¨åˆ°Tï¼Œæ‰€ä»¥è¿™æ ·çš„æ£€æŸ¥æ˜¯å¾ˆæœ‰å¿…è¦çš„ã€‚

ä½†æ˜¯éšç€ç‰ˆæœ¬çš„æ›´æ–°ï¼Œé€šè¿‡ï¼š

``` rust
struct Vec<T> {
    data: *const T, // `*const` for variance!
    len: usize,
    cap: usize,
}

# #[cfg(any())]
impl<T> Drop for Vec<T> { /* â€¦ */ }
```

è¯­æ³•å³å¯é€šçŸ¥ç¼–è¯‘å™¨æˆ‘ä»¬æŒæœ‰Tå¹¶ä¼šåœ¨ææ„å‡½æ•°ä½¿ç”¨ï¼Œè§¦å‘ææ„æ£€æŸ¥ï¼Œæ­¤æ—¶æ·»åŠ PhantomDataå°±æ˜¯æ²¡å¿…è¦çš„äº†ã€‚è¿™æ ·çš„é™åˆ¶ä¼šå¯¼è‡´å®ç°èµ·æ¥ä¸æ–¹ä¾¿ï¼Œæ‰€ä»¥æ ‡å‡†åº“çš„Vecå®åˆ™ä½¿ç”¨äº†[#may_dangle]æ¥æ ‡æ³¨ææ„æ–¹æ³•ã€‚

PhantomDataçš„ä¸€ä¸ªç”¨æ³•æ˜¯ï¼Œæ ‡å‡†åº“é’ˆå¯¹éœ€è¦åˆ†é…ç©ºé—´çš„è£¸æŒ‡é’ˆçš„å°è£…ï¼šUnique<T>ï¼Œå®ƒç”¨åˆ°äº†ï¼š

- *const Tç”¨æ¥å®ç°åå˜
- PhantomData<T>æ¥å®ç°æ‹¥æœ‰T
- è‡ªåŠ¨æ´¾ç”ŸÂ·Send/Sync
- æ ‡è®°æŒ‡é’ˆä¸ºéç©ºä»¥æ­¤å®ç°éç©ºæŒ‡é’ˆä¼˜åŒ–

æ¥çœ‹ä¸€ä¸ªæ‰€æœ‰PhantomDataå¯èƒ½çš„ä½¿ç”¨åœºæ™¯ï¼š

| Phantom type                | `'a`      | `T`                         | `Send`    | `Sync`    |
|-----------------------------|-----------|-----------------------------|-----------|-----------|
| `PhantomData<T>`            | -         | covariant (with drop check) | `T: Send` | `T: Sync` |
| `PhantomData<&'a T>`        | covariant | covariant                   | `T: Sync` | `T: Sync` |
| `PhantomData<&'a mut T>`    | covariant | invariant                   | `T: Send` | `T: Sync` |
| `PhantomData<*const T>`     | -         | covariant                   | -         | -         |
| `PhantomData<*mut T>`       | -         | invariant                   | -         | -         |
| `PhantomData<fn(T)>`        | -         | contravariant               | `Send`    | `Sync`    |
| `PhantomData<fn() -> T>`    | -         | covariant                   | `Send`    | `Sync`    |
| `PhantomData<fn(T) -> T>`   | -         | invariant                   | `Send`    | `Sync`    |
| `PhantomData<Cell<&'a ()>>` | invariant | -                           | `Send`    | -         |
