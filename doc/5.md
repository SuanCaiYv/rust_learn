终于来到了官方文档学习的最后一章：死灵术！

本文将不再按照原有书籍顺序组织编写，而是根据我自己的使用经验排版，同时内容不限于nomicon，会包括所有我了解到的Rust底层相关的知识。

那么我们开始吧！

### 关于Unsafe

裸指针可以做的事只有五种：

- 解引用裸指针；比如UnsafeCell使用到的不可变引用 -> 可变引用
- 调用Unsafe函数(比如C函数，编译器内联函数，以及原生内存分配器)
- 实现Unsafe的特征；比如手动为自己的类型实现Send以及Sync
- 可变全局变量；
- 访问C联合体的字段；这个我用的不多，如果和C交互比较多则会用到

为什么上述五种行为必须需要Unsafe限定，根本原因在于它们可能导致UB(Undefined Behavior)。

当你需要和Unsafe交互时，应该遵循着尽可能少的Unsafe扩散原则；即如果代码含有Unsafe，应尽可能使用私有方法，模块化等手段限制外部对其的访问。对于Unsafe的编写应该尽最大可能去审查和认真考量，避免在Safe的Rust中产生因为Unsafe处理不当而导致的意外崩溃。

举个简单的例子来看，std之下的Vec，其内部实现用了Unsafe来优化和编写，但是它最终对外暴露了Safe的API，通过严格的测试和编写，最终保证了Safe的Rust，这样通过限制Unsafe可见性的方式，正是合理使用Unsafe的一种证明。

### 关于Repr

Repr可以理解为内存表现形式，或者在内存中的存放方式。涉及到的无非就是偏移量和对齐，这一点详细的内容可以参考[参考手册](./4.md)中的详细叙述。

这里说一下ZST类型，即大小为零的类型，目前有这几种：

``` rust
struct Nothing; // No fields = no size

// All fields have no size = no size
struct LotsOfNothing {
    foo: Nothing,
    qux: (),      // empty tuple has no size
    baz: [u8; 0], // empty array has no size
}
```

关于ZST类型，Rust编译器会做出一些特殊优化，让那些涉及到ZST的操作为空操作。

最后就是空类型，一个典型的空类型，就是没有枚举值的枚举类型。

有一个很有趣的用法，就是用在Result类型上，并指定Err类型为空类型，则此时随便unwarp()也不会出问题，但是很多从C来的程序员喜欢把空类型和void类型对比，这是不对的，可以创建空类型的引用，但是没法对其解引用。此时*const的用法就出现了！对它解引用会被优化成空操作。

对于空类型的Result，编译器也可以做出优化，即把Result<T, Void>优化为T类型。

### 所有权

先来看一个引用别名问题：

``` rust
fn compute(input: &u32, output: &mut u32) {
    if *input > 10 {
        *output = 1;
    }
    if *input > 5 {
        *output *= 2;
    }
    // remember that `output` will be `2` if `input > 10`
}
```

优化之后的代码如下：

``` rust
fn compute(input: &u32, output: &mut u32) {
    let cached_input = *input; // keep `*input` in a register
    if cached_input > 10 {
        // If the input is greater than 10, the previous code would set the output to 1 and then double it,
        // resulting in an output of 2 (because `>10` implies `>5`).
        // Here, we avoid the double assignment and just set it directly to 2.
        *output = 2;
    } else if cached_input > 5 {
        *output *= 2;
    }
}
```

这在别的语言是有问题的，因为input和output可以指向同一个内存，但是在Rust这是不可能的！所以编译器可以直接做出优化而不用担心因为参数别名(指 指向同一个内存区域时)导致的错误。

对于引用别名的分析，可以促使编译器做出很多优化，比如上述的别名分析结果是输入输出互不影响，所以可以直接进行代码优化。类似的行为还有：

- 缓存内存访问读操作为寄存器访问
- 重排序读写操作

上述一个通用语言优化的版本应该是这样的：

``` rust
fn compute(input: &u32, output: &mut u32) {
    let mut temp = *output;
    if *input > 10 {
        temp = 1;
    }
    if *input > 5 {
        temp *= 2;
    }
    *output = temp;
}
```

关于生命周期省略，生命周期局限性，以及无界生命周期，想必想代码的时候遇到过很多吧！这里就不再赘述。来看看高阶生命周期约束