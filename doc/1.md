## 基础

在这里我们不讲什么变量定义，控制语句，关键词之类的基础，我们只讲那些，Rust独有的，比较有难点的东西。

#### 基本类型

Rust的基本类型包括：

- i家族：i8 i16 i32 i64 i128

- u家族：u8 u16 u32 u64 u128

- f家族：f32 f64

- bool

- char，注意，Rust的Char是UTF-8编码的，即'🥺'算是一个字符。这也导致对于字符串的处理需要额外小心。

此外，Rust还有一些特殊类型，除去元组这个某些语言有，某些语言没有的东西，另外就是单元类型：()和发散类型：! 对没错，小括号和感叹号是两个类型。

#### 独有类型

**单元类型**类似Go的空结构体，可以**作为占位符**使用，也可以**作为C的void**使用，单元类型的值就是()，是的，它类型和值都是小括号。而且它**表示函数返回空**，比如main()函数可以理解成main返回单元类型，即返回空。

此外，在Rust中函数返回空是算返回值的，真正**没有返回值的是发散类型**，即返回值为!的函数，它**表示函数永不返回**，可以用于指出某一函数尚未实现。

#### 所有权机制

首先，所有语言都无法回避的一个事实是资源回收问题，而这个问题的典型就是内存回收，所以编程语言分为了两大类：手动回收内存和GC回收。然而Rust选择了第三种方式：编译器回收，即所有权系统。

- 所有权系统：解决内存释放问题和二次释放问题。

- 生命周期系统：解决悬垂引用问题。

Rust中的一个普通的赋值语句：let a = XXX；a称为变量，即variable；而XXX称为内存对象，也叫做值，即value。每一个赋值操作称为值绑定，因为此时不仅仅对变量进行了赋值，我们还把值的所有权一并加到了变量上。

- Rust中一个值只有一个变量拥有它的所有权

当**拥有所有权的变量离开了自己的作用域**时，与它**绑定的值就被析构函数释放**了，进而完成资源的释放。或者说，所有权保证了值的生存，值一旦失去所有权，就会被释放，而所有权是变量负责保存的。

使用变量a给另一个变量b赋值，会发生所有权转移，此时新的变量b将对值负责，a也**无法再次使用**。

- 所有权是一个编译器抽象的概念，它不存在于实际的代码中，它仅仅是一种思想。

#### 所有权和Copy

不是每一次赋值操作都会导致所有权转移，对于T类型而言，使用变量a对变量b进行赋值，如果**T实现了Copy**，那么**会发生一次副本操作**，即，发生一次完整的内存复制，此时**a和b各自绑定独立的值**，互不干扰，只是它们的值内容相同。

而**没有实现Copy**的类型，则**会发生所有权转移**，又称为“**移动**”，此时除了所有权转移，**同样会发生值的复制**，就和C语言的普通赋值一样，只是这一次所有权不会复制，a的值将被释放，因为它的值的所有权被移走了。还记得我们前面说的吗？失去了所有权的值将被释放。

这样来看，Copy仅仅保证所有权是否被Duplicate。

#### Copy和Clone

既然说到了Copy，顺嘴提一下Clone。Clone是Copy的父trait。实现了Copy的T类型必须实现Clone。

- Copy：强调位复制，且仅作用于存储在栈上和**非Drop**的类型。由编译器实现，无法自行实现。

- Clone：强调副本有效性，会进行深拷贝，保证新的值完全有效。可由用户自行实现。

更加详细地见[这里](https://rustcc.cn/article?id=c3fc25cf-dab6-4b51-8547-1ff4aacbfc32)

Copy本质是一个编译器trait，用于标注一个类型是否可Copy。它无法被主动实现，想要某个T类型实现Copy，可通过派生宏进行派生，**当且仅当所有字段均是Copy类型是，T才是Copy的**。

一般而言，基本类型都是Copy的，数组或元组的元素类型全部是Copy的，数组或元组才是Copy的。

#### 不想要所有权？引用登场

有些时候我们仅仅想要使用对象，而不想获得所有权，比如一个打印函数，肯定只想读取变量，不然打印完还要把所有权返回出去可太麻烦了！此时我们引入**引用**这个概念。

引用正如绝大多数语言中的指针。对于T类型，它的引用类型是&T，是一个指向内存对象的指针，引用变量保存着内存对象的地址。

- 引用类型不会获得所有权。

引用分为可变引用和不可变引用。

- 在同一作用域下，只能存在一个可变引用或多个不可变引用。

此外，引用的作用域比变量小一些，变量直到离开作用域才被认为可以回收了，引用一旦不再使用便认为不会影响后续操作了。

所有的引用类型都是Copy的，即使用引用赋值另一个引用不会转移这个引用的所有权，其实就是获得了两个指向同一对象的指针；注意，这里是引用的所有权，而不是引用引用的对象的所有权。Rust中所有的值都有所有权，引用类型的值也是值。

如果我们即想获得所有权，还不想复制T类型，减少内存复制开销时，该怎么办呢？可以使用Box类型进行包装。

#### DST和Fat Pointer

提到了引用类型，我们不得不提一下切片引用和宽指针这个概念。

在Rust中，有一些类型，它们的大小编译期无法确定，但是我们又不想，或者不能把它们留到运行期处理，这些类型称为动态类型，即DSTs。

你可能会疑惑？类型大小不是确定的吗？怎么会不清楚呢？以数组为例，Rust的数组类型，定义为：[T;size]，其类型由T和大小size组成。

而切片类型：[T]则没有size，所以它的大小是不确定的，我们不知道一个切片到底引用了多长的数组不是吗？

类似的还有trait，我们也不知道实现了这个trait的类型到底是什么样的，而可能有多个不同的类型都实现了这个trait，每个类型都有自己的大小，所以它的大小也是不确定的。

**对于DST类型，我们使用它们的指针类型来进行处理**。但是这里的指针类型，不是简单的包含地址，它还包含了附加信息，比如切片指针，还包含了切片长度，所以此时这个指针的大小是8+8=16字节；因为它比一般的指针大，所以我们称之为“宽指针”。

因为DST的宽指针更好用，所以实际使用时，都是使用它们的指针形式，比如&[T]。

最后放一个链接，关于DSTs的[讨论](https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer)

#### &str/String

这里既然提到了&[T]，就不得不说&[u8]和&str以及str和String。**&str就是&[u8]**，**str是String的底层切片**，即**保存字面量的那个数组的切片**，但是刚刚说过一般不用切片，而是用切片的引用，所以一般用&str。

后面为了简单称呼，一般**对切片的引用称为切片**，因为没什么人会真的用切片，大家都用切片引用。

- String用于存储需要动态更改的数据，或者需要所有权的数组。

- &str不存在所有权，一般适用于字面量或不会更改的字符串；字面量会被编译斤可执行文件中，&str便是把这个可执行文件当成一个大号的字节数组，然后对其的引用。

#### 结构体和枚举

Rust的结构体和C以及Go的类似，这里需要注意的是，如果想更改Rust的结构体，需要设置结构体变量为mut，而不能指定某一字段单独为mut。

如果结构体的字段是可以拥有所有权的字段的话，对这样的字段赋值或者构造这样的结构体，会涉及所有权转移问题。

let a = b操作用于结构体类型时，不仅仅会转移结构体的所有权，还会转移字段的所有权(如果字段不是Copy的话)。

#### 枚举+match

Rust的枚举类型很强大，有一点就是，它的枚举实例的值，可以是不同类型的；这一点在Result和Option被展现的淋漓尽致。枚举通常和match搭配使用，很重要的一点就是match可以获取到枚举实例中保存的值。

match语句必须包含 _ 情况，即“default”情况作为全部失配的候选。

#### if let

此外还有if let语句，它用来匹配某一确定值的枚举实例而忽略其他所有可能，所以何时用if let，何时用match，取决于是否需要匹配某一确定的枚举实例值(注意不是枚举值，是枚举实例内部的值)。

#### 模式匹配

Rust的模式匹配相当常见，赋值语句，元组赋值，for循环，match匹配，结构体和元组的解构，if let等，都是模式匹配，**模式匹配要求右侧表达式符合左侧变量语法，即右侧值序列同左侧变量序列的类型，顺序，数量一致**。

#### 方法

Rust的方法同大多数面向对象的语言的方法，如果**方法第一个参数是self/&self/&mut self；则这是一个实例方法，否则是一个静态方法**。但是实例方法我们一般都用&self/&mut self，即当前对象的引用，如果是self则表示要获得这个对象的所有权，此时可能是基于当前对象构建新的对象。

#### 泛型

Rust的泛型如同C++的模版，都是单态化编译，即针对每一个类型生成一个泛型方法。此外，Rust针对数组这样编译期确定大小的类型添加了值泛型，既然泛型会在编译后单态化，而数组大小也是一个编译常量，那为何不把数组大小作为泛型参数使用呢？这样编译后就得到了一个大小对应一个函数的结果，然后每个函数再对数组进行独立地实例化即可。

#### trait

Rust的trait类似其他语言的接口，它是一组行为的集合，除了简单的作为接口使用，它还可以作为函数参数和返回值使用。

Rust的trait有一套称为“孤儿原则”的规则，即**实现了trait的类型或者trait，至少有一个是在当前作用域定义**的，否则可能发生某一类型被加上了其他的不相关的trait的情况。

Rust的trait作为函数参数时，除了直接写在参数列表中，还可以使用特征约束(trait bound)的语法，指出传参类型必须实现了哪些trait。同时可以通过 '+' 指出多个约束；也可以使用Where语句进行更加清晰地描述。

除了作为函数参数，trait还可以作为函数返回值，但是，此时只能返回一种类型，即使返回的多个类型都实现了这个trait，编译器也会报错。

#### 特征对象

前面说函数无法返回不同的实现了同一特征的类型，因为返回的多个类型其实际大小不一致，无法转换到同一个特征变量上去，所以我们会使用特征对象引用来替代。

特征对象引用的类型是特征的引用，即&trait类型。特征对象引用就是典型的**宽指针**。既然返回值的大小可能不一样，那我保存指针不就得了，指针大小可是一样的啊！特征对象引用就由两个指针构成，分别是**实际类型指针和虚方法表指针**。学过Go可以把特征对象类比为interface{}类型。

特征对象引用的类型是&dyn trait，但是在实际传参时仅需使用&val取地址即可，而不用指出dyn，这里的dyn仅在声明时表示这是一个特征对象引用类型。

特征对象的虚方法表仅包含特征定义的方法，而不包含实际类型的其他方法。

