## 基础

在这里我们不讲什么变量定义，控制语句，关键词之类的基础，我们只讲那些，Rust独有的，比较有难点的东西。

### 基本类型

Rust的基本类型包括：

- i家族：i8 i16 i32 i64 i128

- u家族：u8 u16 u32 u64 u128

- f家族：f32 f64

- bool

- char，注意，Rust的Char是UTF-8编码的，即'🥺'算是一个字符。这也导致对于字符串的处理需要额外小心。

此外，Rust还有一些特殊类型，除去元组这个某些语言有，某些语言没有的东西，另外就是单元类型：()和发散类型：! 对没错，小括号和感叹号是两个类型。

#### 独有类型

**单元类型**类似Go的空结构体，可以**作为占位符**使用，也可以**作为C的void**使用，单元类型的值就是()，是的，它类型和值都是小括号。而且它**表示函数返回空**，比如main()函数可以理解成main返回单元类型，即返回空。

此外，在Rust中函数返回空是算返回值的，真正**没有返回值的是发散类型**，即返回值为!的函数，它**表示函数永不返回**，可以用于指出某一函数尚未实现。

### 所有权机制

首先，所有语言都无法回避的一个事实是资源回收问题，而这个问题的典型就是内存回收，所以编程语言分为了两大类：手动回收内存和GC回收。然而Rust选择了第三种方式：编译器回收，即所有权系统。

- 所有权系统：解决内存释放问题和二次释放问题。

- 生命周期系统：解决悬垂引用问题。

Rust中的一个普通的赋值语句：let a = XXX；a称为变量，即variable；而XXX称为内存对象，也叫做值，即value。每一个赋值操作称为值绑定，因为此时不仅仅对变量进行了赋值，我们还把值的所有权一并加到了变量上。

- Rust中一个值只有一个变量拥有它的所有权

当**拥有所有权的变量离开了自己的作用域**时，与它**绑定的值就被析构函数释放**了，进而完成资源的释放。或者说，所有权保证了值的生存，值一旦失去所有权，就会被释放，而所有权是变量负责保存的。

使用变量a给另一个变量b赋值，会发生所有权转移，此时新的变量b将对值负责，a也**无法再次使用**。

- 所有权是一个编译器抽象的概念，它不存在于实际的代码中，它仅仅是一种思想。

### 所有权和Copy

不是每一次赋值操作都会导致所有权转移，对于T类型而言，使用变量a对变量b进行赋值，如果**T实现了Copy**，那么**会发生一次副本操作**，即，发生一次完整的内存复制，此时**a和b各自绑定独立的值**，互不干扰，只是它们的值内容相同。

而**没有实现Copy**的类型，则**会发生所有权转移**，又称为“**移动**”，此时除了所有权转移，**同样会发生值的复制**，就和C语言的普通赋值一样，只是这一次所有权不会复制，a的值将被释放，因为它的值的所有权被移走了。还记得我们前面说的吗？失去了所有权的值将被释放。

这样来看，Copy仅仅保证所有权是否被Duplicate。

### Copy和Clone

既然说到了Copy，顺嘴提一下Clone。Clone是Copy的父trait。实现了Copy的T类型必须实现Clone。

- Copy：强调位复制，且仅作用于存储在栈上和**非Drop**的类型。由编译器实现，无法自行实现。

- Clone：强调副本有效性，会进行深拷贝，保证新的值完全有效。可由用户自行实现。

更加详细地见[这里](https://rustcc.cn/article?id=c3fc25cf-dab6-4b51-8547-1ff4aacbfc32)

Copy本质是一个编译器trait，用于标注一个类型是否可Copy。它无法被主动实现，想要某个T类型实现Copy，可通过派生宏进行派生，**当且仅当所有字段均是Copy类型是，T才是Copy的**。

一般而言，基本类型都是Copy的，数组或元组的元素类型全部是Copy的，数组或元组才是Copy的。

### 不想要所有权？引用登场

有些时候我们仅仅想要使用对象，而不想获得所有权，比如一个打印函数，肯定只想读取变量，不然打印完还要把所有权返回出去可太麻烦了！此时我们引入**引用**这个概念。

引用正如绝大多数语言中的指针。对于T类型，它的引用类型是&T，是一个指向内存对象的指针，引用变量保存着内存对象的地址。

- 引用类型不会获得所有权。

引用分为可变引用和不可变引用。

- 在同一作用域下，只能存在一个可变引用或多个不可变引用。

此外，引用的作用域比变量小一些，变量直到离开作用域才被认为可以回收了，引用一旦不再使用便认为不会影响后续操作了。

所有的引用类型都是Copy的，即使用引用赋值另一个引用不会转移这个引用的所有权，其实就是获得了两个指向同一对象的指针；注意，这里是引用的所有权，而不是引用引用的对象的所有权。Rust中所有的值都有所有权，引用类型的值也是值。

如果我们即想获得所有权，还不想复制T类型，减少内存复制开销时，该怎么办呢？可以使用Box类型进行包装。

#### 引用和指针

这里提一下引用和指针。引用有两种类型：`&T`和`&mut T`，指针亦是如此：`*const T`和`* T`，分别都是可变和不可变。他们的值都是被引用/被指向对象的地址，但是不同在于：

- 定义方式不同：一个&一个*
- 编译器处理不同：引用会涉及生命周期检查和可变性/多个不可变性检查；而指针则不存在这些，甚至无法保证指向的数据不会被更改或者删除，所以放在了unsafe中进行详细讲述

同样，对二者的使用都涉及到解引用操作，因为保存的都是地址。通俗一点来说，**引用是被编译器加了限制的指针**。

### DST和Fat Pointer

提到了引用类型，我们不得不提一下切片引用和宽指针这个概念。

在Rust中，有一些类型，它们的大小编译期无法确定，但是我们又不想，或者不能把它们留到运行期处理，这些类型称为动态类型，即DSTs。

你可能会疑惑？类型大小不是确定的吗？怎么会不清楚呢？以数组为例，Rust的数组类型，定义为：[T;size]，其类型由T和大小size组成。

而切片类型：[T]则没有size，所以它的大小是不确定的，我们不知道一个切片到底引用了多长的数组不是吗？

类似的还有trait，我们也不知道实现了这个trait的类型到底是什么样的，而可能有多个不同的类型都实现了这个trait，每个类型都有自己的大小，所以它的大小也是不确定的。

**对于DST类型，我们使用它们的指针类型来进行处理**。但是这里的指针类型，不是简单的包含地址，它还包含了附加信息，比如切片指针，还包含了切片长度，所以此时这个指针的大小是8+8=16字节；因为它比一般的指针大，所以我们称之为“宽指针”。

因为DST的宽指针更好用，所以实际使用时，都是使用它们的指针形式，比如&[T]。

最后放一个链接，关于DSTs的[讨论](https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer)

#### &str/String

这里既然提到了&[T]，就不得不说&[u8]和&str以及str和String。**&str就是&[u8]**，**str是String的底层切片**，即**保存字面量的那个数组的切片**，但是刚刚说过一般不用切片，而是用切片的引用，所以一般用&str。

后面为了简单称呼，一般**对切片的引用称为切片**，因为没什么人会真的用切片，大家都用切片引用。

- String用于存储需要动态更改的数据，或者需要所有权的数组。

- &str不存在所有权，一般适用于字面量或不会更改的字符串；字面量会被编译斤可执行文件中，&str便是把这个可执行文件当成一个大号的字节数组，然后对其的引用。

### 结构体和枚举

Rust的结构体和C以及Go的类似，这里需要注意的是，如果想更改Rust的结构体，需要设置结构体变量为mut，而不能指定某一字段单独为mut。

如果结构体的字段是可以拥有所有权的字段的话，对这样的字段赋值或者构造这样的结构体，会涉及所有权转移问题。

let a = b操作用于结构体类型时，不仅仅会转移结构体的所有权，还会转移字段的所有权(如果字段不是Copy的话)。

### 枚举+match

Rust的枚举类型很强大，有一点就是，它的枚举实例的值，可以是不同类型的；这一点在Result和Option被展现的淋漓尽致。枚举通常和match搭配使用，很重要的一点就是match可以获取到枚举实例中保存的值。

match语句必须包含 _ 情况，即“default”情况作为全部失配的候选。

#### if let

此外还有if let语句，它用来匹配某一确定值的枚举实例而忽略其他所有可能，所以何时用if let，何时用match，取决于是否需要匹配某一确定的枚举实例值(注意不是枚举值，是枚举实例内部的值)。

#### 模式匹配

Rust的模式匹配相当常见，赋值语句，元组赋值，for循环，match匹配，结构体和元组的解构，if let等，都是模式匹配，**模式匹配要求右侧表达式符合左侧变量语法，即右侧值序列同左侧变量序列的类型，顺序，数量一致**。

### 方法

Rust的方法同大多数面向对象的语言的方法，如果**方法第一个参数是self/&self/&mut self；则这是一个实例方法，否则是一个静态方法**。但是实例方法我们一般都用&self/&mut self，即当前对象的引用，如果是self则表示要获得这个对象的所有权，此时可能是基于当前对象构建新的对象。

### 泛型

Rust的泛型如同C++的模版，都是单态化编译，即针对每一个类型生成一个泛型方法。此外，Rust针对数组这样编译期确定大小的类型添加了值泛型，既然泛型会在编译后单态化，而数组大小也是一个编译常量，那为何不把数组大小作为泛型参数使用呢？这样编译后就得到了一个大小对应一个函数的结果，然后每个函数再对数组进行独立地实例化即可。

### trait

Rust的trait类似其他语言的接口，它是一组行为的集合，除了简单的作为接口使用，它还可以作为函数参数和返回值使用。

Rust的trait有一套称为“孤儿原则”的规则，即**实现了trait的类型或者trait，至少有一个是在当前作用域定义**的，否则可能发生某一类型被加上了其他的不相关的trait的情况。

Rust的trait作为函数参数时，除了直接写在参数列表中，还可以使用特征约束(trait bound)的语法，指出传参类型必须实现了哪些trait。同时可以通过 '+' 指出多个约束；也可以使用Where语句进行更加清晰地描述。

除了作为函数参数，trait还可以作为函数返回值，但是，此时只能返回一种类型，即使返回的多个类型都实现了这个trait，编译器也会报错。

### 特征对象

前面说函数无法返回不同的实现了同一特征的类型，因为返回的多个类型其实际大小不一致，无法转换到同一个特征变量上去，所以我们会使用特征对象引用来替代。这里需要指出，特征对象和特征对象引用的关系和切片以及切片引用的关系一样，特征对象由实际类型，静态类型，类型大小组成，而实际类型及其大小是编译期不可知的，所以无法直接使用，一般使用其引用类型。

特征对象引用的类型是特征的引用，即&trait类型。特征对象引用就是典型的**宽指针**。既然返回值的大小可能不一样，那我保存指针不就得了，指针大小可是一样的啊！特征对象引用就由两个指针构成，分别是**数据指针和虚方法表指针**。学过Go可以把它类比为interface{}类型。

特征对象引用的类型是&dyn trait，但是在实际传参时仅需使用&val取地址即可，而不用指出dyn，这里的dyn仅在声明时表示这是一个特征对象引用类型。

特征对象引用的虚方法表仅包含特征定义的方法，而不包含实际类型的其他方法。

最后，同上，因为一般使用引用类型，所以特征对象的引用一般称为特征对象，如无特别说明，它们指的都是引用类型。

#### self和Self

self用来指代当前对象，Self用来指代当前类型名称，这会导致编译时进行名称替换，把Self替换成具体的类型名称。

为什么会突然提到这个呢？因为特征对象有两个限制：

 - 方法返回值不能是Self
 - 方法参数不能含有泛型

关于第一个限制，很好理解，因为具体类型不需要被记录，特征对象仅包含两个指针即可，所以Self无法在编译时被翻译(解析特征对象是运行时的事)；第二个限制也是类似的，泛型是具体类型的类型参数，而不是特征的参数，具体类型都被抹掉了，那么作为具体类型参数的泛型参数肯定也无法被记录。

#### 关联类型

关联类型，字面意思，就是关联到一个类型上的参数，比如我们可以给类型T关联一个类型M，然后T的方法可能会用到M类型。比如如下代码：

``` rust
trait Converter {
    // 这里设置绑定的类型
    type Output;

    // 这里指出返回值类型为与当前类型绑定的类型(在实现类中就是与实现类绑定的类型)
    fn work(&self) -> Self::Output;
}

impl Converter for i32 {
    // 这里指出绑定的类型是什么
    type Output = i64;

    fn work(&self) -> Self::Output {
        *self as i64
    }
}

pub fn trait_learn() {
    let a: i32 = 12;
    let b = a.work();
    println!("{}", b)
}
```

关联类型和泛型的区别在于，可读性。是的，关联类型可读性高一些。

此外，对于泛型类型，可以指定一个默认类型，比如在重载运算符时，可以把默认类型设为当前类型，这样在实现时，就不需要显示指明泛型类型：

``` rust
trait Plus<T=Self> {
    fn plus(&self, v: &T) -> Self;
}

// 这里省略了<T=i32>
impl Plus for i32 {
    fn plus(&self, v: &Self) -> Self {
        *self + *v
    }
}

// 这里则显示指出了参数的类型
impl Plus<f64> for i64 {
    fn plus(&self, v: &f64) -> Self {
        *self + (*v) as i64
    }
}

pub fn default_generics() {
    let a: i32 = 1;
    let b: i32 = a.plus(&2);
    println!("{}", b);
    let c: i64 = 3;
    let d: i64 = c.plus(&4_f64);
    println!("{}", d)
}
```

对于同名方法的调用，遵循实例方法优先原则，如果想通过实例对象指定某一trait的方法，则需要使用限定方式。

此外，对于多个trait的同名类方法，需要使用完全限定语法。

对于特征的限制，也可以使用类似别的语言的父接口那样，限制当前trait的实现原则，比如指出当前trait必须先实现哪个trait，才能实现当前trait。

### 类型转换

对于普通的类型转换，使用`as`关键字进行处理即可，如果想要处理溢出问题，可以使用`TryInfo`trait进行处理。此外，为了简化编写，Rust允许直接进行类型转换。

### Error or panic?

panic!()宏用于处理不可恢复的错误，它会导致当前线程终止，而如果当前线程是main线程的话，则会导致程序退出。

对于想要手动处理的错误，可以使用Result枚举来完成，它包含两个枚举值：OK和Err。对于一个函数的返回值，我们当然可以通过match进行匹配：

``` rust
fn main() {
    match error_result(false) {
        Ok(str) => {
            println!("{}", str)
        }
        Err(err) => {
            println!("err: {}", err)
        }
    }
}

pub fn error_result(flag: bool) -> Result<String, String> {
    if flag {
        Ok(String::from("success"))
    } else {
        Err(String::from("failed"))
    }
}
```

此外，也可以进行错误链抛出，即当前方法遇到Err时，抛出到主调方，这就要求当前方法可以分别处理Ok和Err两种情况：

``` rust
fn f() -> Result<String, String> {
    match error_result(false) {
        Ok(str) => {
            println!("{}", str);
            Ok(String::from("1"))
        }
        Err(err) => {
            println!("err: {}", err);
            Err(String::from("2"))
        }
    }
}

pub fn error_result(flag: bool) -> Result<String, String> {
    if flag {
        Ok(String::from("success"))
    } else {
        Err(String::from("failed"))
    }
}
```

这样写起来未免有些啰嗦，甚至步入了Go的后尘，所以这里有一个编译器宏：`?`来简化处理，它会在返回结果为Err时，直接返回Err到主调方，而在返回Ok时，提取结果作为函数返回值使用：

``` rust
fn f() -> Result<String, String> {
    let v = error_result(true)?;
    println!("{}", v);
    Ok(String::from("1"))
}

pub fn error_result(flag: bool) -> Result<String, String> {
    if flag {
        Ok(String::from("success"))
    } else {
        Err(String::from("failed"))
    }
}
```

此外，这种方式亦可用于Option，在Option返回None时，返回当前函数，否则提取Some的值。

### 项目组织

Rust的项目组件，从小到大可分为：

- 模块：组织和限定Rust基本组件，比如组织同类的方法，结构体等。
- 包(crate)：组织模块的单元，一个项目可以包含一个lib和多个bin包，它们在crago.toml文件中定义。
- 工作空间：组织多个包的单元。
- 项目(package)：组织整个项目的存在。

这里需要留意，在别的语言中package是包的意思，在Rust中，是软件包的意思，即项目包，也即项目，而create才是包。下面如无特别说明，包都是crate，而不是package。

package有两种：

- 二进制(bin)：可直接运行，作为一个独立的App存在。
- 库(lib)：作为第三方库被其他项目引用，无法独立运行。

模块常用来组织行为。同时可以进行界限划分，同名的行为允许存在在不同的模块中，这是不冲突的。这里可以把模块和Go的包类比，二者都定义了一些方法，结构体，都进行了空间划分，都可以设定成员可见性。

这里需要指明一下，对于结构体，在模块中指定结构体为pub不能把成员也编程pub的，必须手动指定成员。但是对于枚举，如果枚举是pub的，则枚举及其内部成员都是pub的。

模块一般定义在src/lib.rs(库包)或src/bin.rs(二进制包)中，但是也可以创建别的文件，然后引用即可，默认引用的模块名为文件名。

### 其他

注释。Rust的注释和其他语言一样，分为行注释和块注释，此外，它的注释支持markdown格式，也可以像Java那样生成doc的网页形式。

关于格式化输出，Rust没有%d, %s, %f这些，而是统一使用`{}`并让编译器区分参数类型。这里说一些常用的：

- {}：调用被输出对象的Display trait输出
- {:?}：调用Debug输出
- {:p}：输出地址
- {:05}：限制长度为5并使用前导0填补

## 高阶

### 生命周期

号称Rust最难的部分终于到来了！但其实也没那么难，只是比较新的概念罢了。

**生命周期是一个帮助编译期分析引用依赖关系以判断引用存活范围是否会引起不正当行为的手段**。编译期：呵！男人，不过是取悦我的手段罢了！生命周期标注不会扩大或缩小引用的生命周期，它**仅仅是给编译期的提示**。

通俗一点来说，如果有一个函数返回了一个引用，那么这个引用的存活时间该怎么判断呢？首先需要知道，返回的引用必然是参数处理过来的，不可能是函数体创建的，在函数栈被回收之后这个引用必然失效，编译期不会允许的(使用Box强制分配怼另说)。所以我们需要通过参数的存活区间来限定返回值的存活区间。

一个函数有多个参数，返回的引用的生命周期，到底该和谁看齐呢？**假设返回值依赖N个参数中的M个参数的生命周期，则返回值的生命周期就是最小的那个**。

生命周期不仅仅存在于函数中，还存在于结构体中，如果字段包含引用，则**结构体实例的生命周期必然小于字段的生命周期**。

为了简化开发，Rust存在一些函数中可以推断出生命周期的场景，进而无需标注即可使用，这些场景是否可行依赖三个原则：

- 每一个参数都有自己的生命周期。
- 如果只有一个参数是引用，则返回值生命周期等于参数的生命周期。
- 如果存在&self/&mut self，则返回值生命周期等于&self/&mut self。

通过上述三个规则去框到某一函数，就能知道这个函数到底可不可以省略生命周期语法。同时我们注意到，方法的生命周期默认等于实例引用的生命周期。当然，如果方法还有别的生命周期，并且你希望返回值依赖它，也可以手动标注出来。上述三个规则只是你懒的不想写时，编译期默认执行的手段而已，不是强制执行的。

生命周期可能造成一些意想不到的编译错误，这些编译错误可能不是你造成的，而是因为编译期能力有限造成的。这里提一些：

- 规则三可能会把self的生命周期拉长，变得和返回值一样，这可能出现意想不到的编译失败，比如扩大一个可变引用到不可变引用的区间，然后因为不可变引用和可变引用的排斥性出现编译失败。
- unsafe代码返回一个指针的指向对象的引用会产生无界生命周期，最好通过函数参数传递一个生命周期，然后把返回值的生命周期绑定到这个参数的生命周期上，完成有界限定。
- 生命周期约束和特征约束类似。'a: 'b表示a的生命周期大于b的，类似的，在结构体实现约束T: 'a，其中a是结构体字段的生命周期，T是字段参数类型，则要求字段引用的数据的存活时间必须大于这个字段。
- 闭包可能涉及更复杂的生命周期分析，不能套函数那一套。
- 再借用允许针对一个引用再次获取它的引用，而无关两个引用类型是否冲突，但是要求第二次借用的引用不能在生命周期内使用第一次引用。
- 实现方法时，如果没有用到生命周期，可以使用下划线`_`进行替代，增加美观度。

这里需要声明一件事，就是生命周期只是用来跟踪被引用数据存活范围的，而不是引用的存活范围，引用本身没有存活范围这一说，我们讨论的都是背后的变量的存活。

在Rust中，有一种特殊的引用，它们的生命周期是'static的，即全局，这种引用所指向的数据会存活直到程序结束。其实也就只有字符串字面量和常量这两个而已。

此外，如果给一个类型T加上'static的约束，表示这个类型本身不是no-static(比如基本类型)或者它不包含no-static的字段(所有的字段要么是所有权要么是'static引用)。这个可能有点绕，说白了就是**拥有'static约束的类型T，它的引用类型不依赖任何其他引用，可以存活任意时间**，或者说存活时间不会被限制，从创建到不再使用为止，而不用担心因为引用了谁而缩小了存活区间。所以所有的基本类型一定满足这一点，自定义类型如果不包含no-static的引用也是满足的。

个人觉得'static可以理解成要求引用的变量自由存活不受限制，而常量比较特殊，会存活整个程序期间，所以它们是天然'static的。
