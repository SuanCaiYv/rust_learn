### 前言

Rust于2018年引入异步，四年后的今天，我第一次接触Rust且使用async/await实现了一个小的IM(即时通讯)系统，带着原本对于Rust的好奇和对于异步的疑惑，翻阅了一些文章和参考，最后得到了一些答案。

在阅读之前，希望读者：

- 了解有限自动状态机
- 熟悉Rust语法
- 了解并使用过Rust异步
- 对于Reactor模型(Epoll/Kqueue处理IO)有所了解

#### 有限自动状态机

又称**状态机**，简称`fsm`，讨论一般情况，一个状态机系统由四个元素组成：

- 状态：State
- 事件：Event，或者条件，指令
- 行为：Action，或者函数，方法
- 转换：Transfer

以自动门的开关为例，可以画出如下状态机转换图：

![](./fsm.svg)

Rust对于异步的实现依赖于状态机。

#### IO多路复用

Linux/macOS/Windows等系统对于非阻塞IO的实现为Epoll/Kqueue/IOCP，其中IOCP支持异步非阻塞IO。以上称为“多路复用IO”，旨在减少因为等待IO而造成的大量线程创建，**提高系统连接数**。具体细节这里不会进行阐述。

#### 异步

关于更好地实现**IO密集型**App的吞吐量和CPU利用率，程序并行化的过程经历了：多进程=>多线程=>协程/异步 这样的发展趋势。来看不同语言的实现：

- Java：Loom实现协程(开发中)，或者Pivotal提出的ReactorProject/VertX等项目实现的响应式IO
- Golang：Goroutine协程
- Kotlin：协程
- Python：异步
- JavaScript：异步

其中协程分为：

- 有栈协程：又名“绿色线程”。比如Goroutine，栈会随着运行动态增长，进而引入了栈收缩伸张等问题
- 无栈协程：比如Python的生成器，不同的执行体跑在当前线程(或者执行者线程)的栈里，没有独属于自己的栈

异步则是协程的一种变种，Rust中选用了这种形式，并且贴近于无栈协程，具体后面会展开。

Rust的异步无法直接运行，**依赖于运行时进行调度**，由于官方的运行时性能欠缺，所以更多使用的是Tokio，具体见Tokio文档。

Rust仅仅定义了异步Task的生成和异步的执行方式，并没有定义异步的调度，对于底层操作的封装(比如IO，定时器，锁等)，所以这就给第三方提供了很多的可能，也为我们自己实现自己的异步运行时提供了机会。

### 概述

#### 生成器

前面提到，Rust的异步类似于无栈协程，而Rust早期对于异步的尝试，则是通过实现Generator的形式实现的。在Python，JavaScript等语言均可以见到生成器的身影，[Generator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator)。

具体来说，生成器负责生成执行体，一个执行体由**可执行代码和数条yield语句**组成，**每一个yield把执行体切分成了不同的执行阶段**。对于执行体的执行，会从上一次中断位置执行，直到遇到下一个yield(中断点/保存点)位置，此时会保存执行体的执行状态，包括更新之后的局部变量等。

通过上述描述，可以想到这和线程切换有些类似，如果把每一个线程看成一个可执行的片段，那么线程切换也是需要保存上下文，进行下一个线程的切换(执行片段的切换)。

理解到这里，就理解了大致的生成器使用原理。

Rust也曾经使用这种方式来处理，但是因为Rust的生命周期和借用规则的存在，导致跨yield保存上下文实现起来比较困难，所以改进之后得到了现在的async/await，即生成器是Rust异步的前身，后面会详细叙述这一点。

Rust中对于生成器有两个主要的定义：

``` rust
pub trait Generator<R = ()> {
    type Yield;

    type Return;

    fn resume(self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return>;
}

pub enum GeneratorState<Y, R> {
    Yielded(Y),

    Complete(R),
}
```

这里的`GeneratorState`则是对应了执行体的状态，每一个yield断点都会得到一个`GeneratorState::Yielded`的枚举值，而执行体结束之后，则会得到一个`GeneratorState::Complete`枚举值。

此外注意到，`Generator::resume()`的返回值对应了`GeneratorState`，侧面说明这个方法负责推进执行体的执行。

至于编译器对于执行体的实现，下面会说。

#### 为什么是生成器？异步哪里去了？

前面说生成器对于横跨保存点的引用处理会比较麻烦，所以优化处理之后得到了异步。在现在版本的Rust异步中，其实现，尤其是编译器对于Future的生成，以及Future内部状态的转移，和生成器的实现看起来差不多，而仅仅在某些名词或者执行推进方式上有些不同。此外对于Future的生成以及处理，是和编译器强耦合的，找到相关的文章或者源码，不太容易，涉及到的代码也仅是LLVM-IR，所以我们借助生成器来理解并尝试使用生成器模拟一个异步定时器。

#### 异步体系

Rust的异步组件可以分为：

- Future：会在未来返回某个值的执行体
- Executor：执行器，负责推进Future的执行，调度多个Future，响应Future的唤醒操作
- Waker：针对某一Future绑定的唤醒器，用于当异步资源就绪时，唤醒执行器继续推进
- Reactor：代表一些异步操作，比如网络，文件IO，或者定时器等会在未来某个时间触发的行为

一般来说，**异步面相IO密集型App**，所以一般来说Reactor就是最底层的Future，其他的操作应该嵌套在Reactor操作之上。

如果按照这样的逻辑去划分，则Future可以分为两类：

- 叶子Future：即本身不会等待任何异步操作的Future，其本身就是一个异步事件
- 非叶子Future：本身的执行需要其他Future的结果，这也是大部分开发者编写的Future的形式

这里给出一个图片：

![](./future_tree.svg)

上图中的箭头循环的含义后面解释。

### 细节

#### Generator

上面提到了yield机制，首先来看看Rust对于生成器生成的执行体，具体编译成了什么样的实现。

通过``



现在我们来看一个具体的使用，请确保你的Rust位Nightly版本：

``` rust
use std::ops::Generator;
use std::pin::Pin;
use std::thread::{sleep, spawn};
use std::time::Duration;

// same as std::ops::Generator
trait MyGenerator<ARG = ()> {
    type Yield;
    type Return;
    fn resume(self: Pin<&mut Self>, arg: ARG) -> MyGeneratorState<Self::Yield, Self::Return>;
}

// same as std::ops::GeneratorState
enum MyGeneratorState<Y, R> {
    Yielded(Y),
    Complete(R),
}

// fsm state set
enum MyGeneratorCodeState {
    Start,
    // in code, we only use String ref, so text is just a referenced object.
    Yield1 {
        text: String,
        text_ref: *mut String,
    },
    Yield2(String),
    Yield3(usize),
    End,
}

impl MyGeneratorCodeState {
    fn new() -> Self {
        Self::Start
    }
}

impl MyGenerator for MyGeneratorCodeState {
    // corresponding to text.len() in MyFuture
    type Yield = usize;
    type Return = ();

    fn resume(mut self: Pin<&mut Self>, arg: ()) -> MyGeneratorState<Self::Yield, Self::Return> {
        match *self {
            MyGeneratorCodeState::Start => {
                // line 1
                let mut s1 = "aaa".to_string();
                // line 2
                let s1_ref = &mut s1;
                // line 3
                println!("curr str: {}", s1_ref);
                let len = s1_ref.len();
                // line 4
                *self = MyGeneratorCodeState::Yield1 {
                    text: s1,
                    text_ref: std::ptr::null_mut(),
                };
                if let MyGeneratorCodeState::Yield1 { ref mut text, ref mut text_ref } = *self {
                    *text_ref = text as *mut String;
                }
                MyGeneratorState::Yielded(len)
            }
            MyGeneratorCodeState::Yield1 { ref mut text, ref mut text_ref } => {
                let mut len = unsafe { (*(*text_ref)).len() };
                // line 5
                println!("curr length: {}", len);
                // line 6
                unsafe { (*(*text_ref)).push_str("state3") };
                // line 7
                let s2 = unsafe { (*(*text_ref)).clone() };
                let len = s2.len();
                // line 8
                *self = MyGeneratorCodeState::Yield2(s2);
                MyGeneratorState::Yielded(len)
            }
            MyGeneratorCodeState::Yield2(ref text) => {
                // line 9
                println!("new str: {}", text);
                // line 10
                *self = MyGeneratorCodeState::Yield3(text.len());
                MyGeneratorState::Yielded(0)
            }
            MyGeneratorCodeState::Yield3(ref value) => {
                // line 11
                println!("new length: {}", value);
                *self = MyGeneratorCodeState::End;
                // line 12
                MyGeneratorState::Complete(())
            }
            MyGeneratorCodeState::End => panic!("MyFuture polled after completion"),
        }
    }
}

pub fn simulate() {
    // this is some generator code, and the fsm code above is compiler result of the code(just simulate).
    let mut generator_code = || {
        // line 1
        let mut s1 = "aaa".to_string();
        // line 2
        let s1_ref = &mut s1;
        // line 3
        println!("curr str: {}", s1_ref);
        // line 4
        yield s1_ref.len();
        // line 5
        println!("curr length: {}", s1_ref.len());
        // line 6
        s1_ref.push_str("state3");
        // line 7
        let s2 = s1_ref.clone();
        // line 8, yield with new str: s2, but yield can only save one type,
        // so the `yield s2.len()` as save s2.len() will be transferred to `save s2` in resume method().
        yield s2.len();
        // line 9
        println!("new str: {}", s2);
        // line 10, yield with new str_length: s2.len()
        yield s2.len();
        // line 11
        println!("new length: {}", s2.len());
        // line 12
    };
    let mut gen = Pin::new(&mut generator_code);
    gen.as_mut().resume(());

    // before you run code blow, remember to comment the code above,
    // case borrow across yield point is not allowed in Rust.
    // 运行代码之前记得注释掉前面的，因为yield使用借用会有问题

    // to verify yield-simulate work, run the code blow.
    let mut gen = MyGeneratorCodeState::new();
    let mut gen = Pin::new(&mut gen);
    gen.as_mut().resume(());
    gen.as_mut().resume(());
    gen.as_mut().resume(());
    gen.as_mut().resume(());
}
```

#### Async/Await

#### Future

#### await or yield / poll() or resume()

#### Waker

#### Executor

### 参考

[Writing an OS in Rust-Async/Await](https://os.phil-opp.com/async-await/)

[The Rust Unstable Book-generators](https://doc.rust-lang.org/beta/unstable-book/language-features/generators.html)

[Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)

[The Waker API I: what does a waker do?](https://boats.gitlab.io/blog/post/wakers-i/)

[How Rust optimizes async/await I](https://tmandry.gitlab.io/blog/posts/optimizing-await-1/)