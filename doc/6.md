## How it implemented?

这是一片剖析std部分实现的文章。

### UnsafeCell

首先看一个自定义Cell：

``` rust
struct MyCell<T> {
    val: T
}

impl<T> MyCell<T> {
    fn new(val: T) -> Self {
        MyCell { val }
    }

    fn set(&self, val: T) {
        let p = &self.val as *const T as *mut T;
        unsafe { p.write(val) }
    }

    fn get(&self) -> T where T: Copy {
        self.val
    }
}

struct Wrapper<'a> {
    cell: MyCell<&'a u64>,
}

/// 'a is outlive 'b
///
/// or says 'a is a sub-type of 'b
///
/// and MyCell<'a T> has covariant over 'a or T
///
/// so MyCell<&'a u64> is a sub-type of MyCell<&'b u64>
///
/// Wrapper<'a T> also has covariant over 'a or T
///
/// and also Wrapper<'a> is a sub-type of Wrapper<'b>
///
/// as a consequence, the convert: &Wrapper<'a> -> &Wrapper<'b> is ok
fn bad_set<'a, 'b>(wrapper: &Wrapper<'a>, val: &'b u64) where 'a: 'b {
    let temp: &Wrapper<'b> = wrapper;
    temp.cell.set(val);
}

fn test(wrapper: &Wrapper) {
    let val = 1;
    // the val is short live than wrapper
    bad_set(wrapper, &val);
}

fn main() {
    let val = 1;
    let wrapper = Wrapper { cell: MyCell::new(&val) };
    test(&wrapper);
    println!("{}", wrapper.cell.get());
}
```

这段代码会出错，但是编译器get不到，错误原因在于访问了野指针。

作为人类，我们可以很容易看到，问题出在了bad_set函数，因为它错误地把更长生命周期的Wrapper强转成了短一些生命周期的Wrapper，之后再进行重新赋值操作，进而导致MyCell存储了一个局部的值。

可是这对于编译器来说是没问题的，因为协变性的存在，MyCell和Wrapper都是协变的，这样的子类型关系是允许的。

解决措施就是禁止协变存在，强制MyCell为不变。这正是UnsafeCell的做法。

把上述代码中的MyCell更改为std::cell::Cell之后，得到报错：

```
requirement occurs because of the type `Wrapper<'_>`, which makes the generic argument `'_` invariant

the struct `Wrapper<'a>` is invariant over the parameter `'a`
```

std::cell::Cell<T>拥有不变性，所以此时发生在bad_set的，基于子类型的转换失效了，触发编译失败。

所以UnsafeCell并不是简单的通过裸指针转换来实现内部可变性，它还有编译器的加持：

``` rust
#[lang = "unsafe_cell"]
pub struct UnsafeCell<T: ?Sized> {
    value: T,
}
```

这里面的标注则是开启不变的关键所在。所以所有的内部可变性应该基于UnsafeCell实现，或者它的变体，否则会出现不健壮的问题。

### Box

