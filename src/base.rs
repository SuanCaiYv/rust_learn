/// 关于基本类型的讨论我们暂时略过。
///
/// ()本身是一个类型，叫做"单元类型"，它的值也是()，类似Go的空结构体struct{}，可以作为"空返回值"或者占位符存在。
///
/// !是一个发散类型，作为函数返回值存在，表示函数永不返回，通常用于标记还未实现的函数，它表示真正的"无返回值"。
///
/// 我们需要明确一件事，就是编程语言中的变量用来寻址内存对象。在Rust中，每一个内存对象(Memory Object)都有一个唯一的变量与之对应。
/// 或者说每一个值(value)都有一个变量(variable)与之"双向"绑定，而引用是变量"单方面"地指向值，所以引用不会导致所有权转移。
///
/// 为了使行为描述更加符合Rust特征，我们把let a = String::from("aaa")称为"变量<=>值 绑定"，虽然这是一个简单的赋值操作。
/// 同时对于let b = a这样的操作称为"移动"，因为b不仅仅是获得了a的值，同时还获得了它的所有权，所以移动这个词描述起来显然更合适。
///
/// 所有权的引入是为了解决内存释放问题。只有拥有所有权的变量离开了作用域，值才会被释放，即，⚠️只有拥有所有权的变量才有资格被析构。
///
/// 刚刚提到了所有权和引用，所有权在重新赋值之后，会发生转移，因为此时重新建立了<=>双向绑定关系，而引用是变量单向引用值，所以所有权不会转移。
/// 引用适用于不想获得所有权而仅仅想获取值的场景下。
///
/// 引用保存的是值的地址，所以在获取之后需要对引用变量解引用，得到被引用的变量，再进行操作。顺带一提，引用变量的类型是&T，其中T是被引用值的类型。
/// 以上概念和C的相关定义没有多大区别。
///
/// ⚠️引用并非是万能的，它有一个限制，就是在同一作用域下，只能存在一个可变引用或者多个不可变引用。
///
/// 同时引用的作用域和变量的作用域是不同的，变量离开作用域，值会被回收，这里的作用域一般指的是花括号{}结束。
/// 而引用的作用域会更小一些，一旦引用不再使用，就算离开作用域，见：code(1)
///
/// 引用的第二个限制是，引用的对象必须存在，假如引用了栈上对象，则可能产生悬垂引用。
///
/// 这里解答一个疑问，如果我基于被引用的变量去操作会怎样？以String为例，基于变量去操作，会获取可变自引用，即当前变量的可变引用；
/// 所以这相当于先获取一个可变引用，再去操作，所以如果在作用域内存在冲突，还是不行滴！
///
/// Rust对于值的存储分为了栈和堆存储，一般而言，存储在栈上的，如果重新绑定到新的变量，则会产生值副本，此时也就不讨论什么所有权和绑定问题了。
/// 而对于堆上的值，如果也想获得副本，可以调用clone()方法获得一个内存对象，然后双向绑定到新的变量上；这比较耗性能。
///
/// 如何判断let b = XXX(变量名)是否会产生副本，还是发生移动呢？这要看XXX的类型是否实现了Copy接口(准确来说是trait，Rust的trait类似别的语言的接口)；
/// 如果实现了，则是副本，否则是移动。
///
/// 判断一个类型是否是可Copy的，可以查阅文档，或者看它是不是基本类型或者基本类型的组合，比如元素类型全部是基本类型的元组类型。
/// 此外，不可变引用类型都是Copy的，可变引用不是！即从一个引用赋值给另一个引用变量会得到两个指向同一内存对象的引用，而不是夺走第一个引用的所有权（而且你要引用所有权有啥用呢？又不是内存对象的所有权
///
/// 这里需要对于所有权和值绑定多逼逼两句，我们以自定义结构体为例：
///
/// 如果结构体所有字段都是Copy的，则let new = old操作会产生栈上复制，即发生新的结构体空间分配操作，即clone操作；
/// 如果有一项不是Copy的，则仅仅转移所有权，依旧发生结构体复制。
///
/// 现在来看看两个比较有意思的trait：Clone和Copy。
/// Copy指的是按位复制，即完全一整个Duplicate；但是仅限于栈内存。所以可以Copy的数据会随着栈缩减而被自动释放。
/// 想一想，Copy仅限于基本类型，以及字段全部为基本类型的复合类型的原因，就是因为这些类型全部可以实现栈上分配，同时Copy是编译级别的trait，程序员无法手动实现，可以标注实现，但成功与否取决于上述规则。
/// Clone是内存复制，且保证副本有效性，什么意思呢？Clone的结果会产生一个完全一致且完全可用的内存区域，所以Clone覆盖栈和堆内存的复制。
/// Clone是Copy的父trait，其实想想，你都实现Copy了，那铁定可以实现Clone。
pub fn base() {
    let str = String::from("str");
    let mut mut_str = String::from("mut_str");
    let ref1 = &str;
    let ref2 = &str;
    let mut_ref1 = &mut mut_str;
    // code(1)
    // 如果尝试把获取引用的函数后移一行，会扩大mut_ref1的作用域，进而违反最多一个可变引用的原则，编译失败
    just_get_ref(mut_ref1);
    let mut_ref2 = &mut mut_str;
}

fn just_get_ref(s: &mut String) {
    println!("{}", s)
}

/// Rust的数组，切片，切片引用，str，&str这些玩意到底是啥？我们一个一个来讲：
///
/// 首先Rust的数组大小是编译期确定的，必须是一个常量表达式。至于动态数组，比如Vec的实现，则是借助unsafe指针实现动态分配，这个暂时不说。
/// Rust的数组写法为：\[T;usize\]，T的元素类型，unsize是数组元素个数；引用写法为\[T\]，大小未知，为什么会未知呢？照理说切片引用数组，
/// 引用多少个元素不是编译期已知的嘛？错啦，你说的是\[from..to\]这样的写法，比如let arr1: \[i32;3\] = \[1, 2, 3\]，let slice1 = arr1\[0..1\]，
/// let slice2 = arr1\[0..2\]，则slice1和slice2都是\[i32\]类型的切片，但是它们大小确实不一样，所以Rust抽象出了\[T\]这个类型来表示T类型的切片，但是大小根据实际情况而定，编译期未知。
///
/// 所以切片是Rust中的DSTs的一种，即"动态大小类型"，当然还有其他的DST，比如trait，后面会说。现在再来引入一个概念，叫做"胖指针"(fat pointer)。它指的是一种特殊的指针类型，有点类似是多个字段拼接而成的。
/// 一般的胖指针都是一个data_ptr+一些附加信息组成(比如长度信息)，此时这样的指针大小就是8+8=16字节。因为比普通的指针8字节大，所以叫胖指针，也叫宽指针。
///
/// 介绍完上面的概念有啥用呢？刚刚我们说了，slice1和slice2都是\[i32\]类型的切片，但是却有着不同的大小，我们又必须通过它的大小来执行编译期检查，那怎么办？
/// 你肯定说："直接给\[T\]类型追加一个长度字段不就完事了吗？"，但是为了美观和强迫症(这我猜的)，Rust没有这么做，取而代之避免使用\[T\]类型，而使用&\[T\]类型。
///
/// 而&\[T\]就是一个胖指针，Rust对于所有的DSTs的类型，都通过它们的指针，来操作，因为指针大小是确定的，所以可以实现编译期处理。如你所猜，切片的引用类型&\[T\]的胖指针由两部分组成：data_ptr+length，总长度在64位机上是16字节。
/// 你可以近似的把&\[T\]类型看成一个包含data_ptr和length字段的结构体，但是胖指针更像把这个结构体压扁了，让它只有这两个字段而没有"结构"。
///
/// 说到这里，我们可以给出一个总结了，就是&\[T\]是一个胖指针类型，大小确定，用来避免直接操作大小不确定的\[T\]类型，后者无法确定大小，进而无法在编译期分配此类型的变量所需的空间，而&\[T\]类型分配16字节足矣，大小确定。
/// 所以一般我们都操作切片的引用，而非切片，也不可能直接通过切片对象去操作，因为编译期都过不去。也可以把它类比成Go的interface{}类型，因为interface{}是一个data_ptr+type_ptr组成的。
///
/// str就是String的底层数组的切片，因为String太常用了，所以专门给它的底层数组切片搞了个名字，当然我们依旧无法直接使用str，所以我们用&str。此外，Rust对于&String做了自动转化，&String == &str。
///
/// 关于&str和String什么时候该用谁的问题：如果数据动态变化，选String，如果是字面量或自始自终都不变的，选&str。
///
/// 切片是个拥有所有权的玩意，但是切片的引用不会获取所有权，这和之前是一样的。到这里你会发现引用类型都是指针类型，顶多是胖瘦指针的区别，你说的没错，所有的指针类型都不会获取所有权，即使这些指针不单单保存值地址。
///
/// 最后放一个链接，关于DSTs的讨论：https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer
///
/// Rust的元组，类似一种抽象组织形式。
///
/// Rust的结构体和大多数语言并无二致，我们只要注意一点就是，Rust的结构体成员在赋值时会移动赋值者的所有权到结构体里面，此外，Rust不允许把某一字段设为可变，而只允许把整个结构体对象设为可变。
/// 如果结构体字段使用了引用，则还需要处理字段的生命周期。
///
/// 除了普通的结构体，还有一种没有字段名的元组结构体，以及类似Go的struct{}的单元结构体，它没有字段，只有一个空空名字，当仅仅想实现结构体方法时，这是很有用的。
///
/// Rust的枚举类型比较强大，它的枚举项可以包含不同类型的值，甚至部分包含值，部分不包含，关于它的介绍，很多时候会和match匹配放在一起，这里只是暂提一下。
///
/// 还有一个很强大的，和枚举类常搭配使用的，是Rust的模式匹配：match，它类似switch语句，包含case和表达式，但是它可以提取出枚举实例的值；此外还有if let语句，它可以进行单枚举实例的匹配。
/// 关于何时使用match，何时使用uf let，有一个简单的规则就是：只是匹配枚举实例某一单一的值，并忽略其他情况时，使用if let，否则使用match。
/// 此外，match必须包含'_'情况的case，相当于switch必须包含default表达式。
///
/// Rust的模式匹配很强大，我们上面说的match仅仅是一种，还有一个很常见的模式匹配，就是赋值语句，他就是把值匹配到了变量上，变量就是一个被匹配的表达式。类似的，还有if let语句，for循环，元组赋值；
/// 解构结构体，元组等等，都是模式匹配的一种，只要匹配的值和表达式语法匹配一致，即可实现模式匹配。全模式匹配列表参见：https://course.rs/basic/match-pattern/all-patterns.html
///
/// Rust的方法，有一些需要注意的点，比如方法如果第一个参数为&self/self/&mut self，则这是一个实例方法，如果没有&self/self/&mut self，则是静态方法，属于结构体类型本身。
/// 此外，self本身用的不多，因为方法依旧遵循所有权，self会把所有权转移到方法里，这一般用于基于此对象重新构建新的实例。而&self/&mut self则是对于对象的引用。
/// 另外，枚举也可以实现方法，就如同结构体一般。
///
/// 现在我们来看看泛型，Rust的泛型是模版泛型，即为每一种类型实现一个方法。这里展示一下泛型语法即可，然后指出常量泛型，即值泛型，这一点常用于数组长度这样的常量传参，但是把它作为泛型实现单态化。
/// 因为我们知道，Rust的数组长度必须是编译期确定的，既然泛型编译后会单态化，那为什么不把长度作为一个值泛型参数，使之编译期单态化呢？这既能实现长度编译期确定的要求，还能减少重复代码！
///
/// 然后是trait，它类似其他语言的接口，即一系列行为的集合。同时它也可以作为函数参数，函数返回值使用
pub fn multi_type() {
    let a: [i32;3] = [1, 2, 3];
    let x = 2;
    let address = &a as *const [i32];
    println!("{:?}", address)
}